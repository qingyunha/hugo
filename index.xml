<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>My Site</title>
    <link>http://qingyunha.github.com/hugo/</link>
    <description>Recent content on My Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 06 Aug 2016 14:38:12 +0800</lastBuildDate>
    <atom:link href="http://qingyunha.github.com/hugo/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>git proxy</title>
      <link>http://qingyunha.github.com/hugo/wiki/git-proxy/</link>
      <pubDate>Sat, 06 Aug 2016 14:38:12 +0800</pubDate>
      
      <guid>http://qingyunha.github.com/hugo/wiki/git-proxy/</guid>
      <description>

&lt;p&gt;Git支持多种传输协议，ssh、git、HTTP(S)，甚至ftp，rsync。&lt;/p&gt;

&lt;p&gt;当使用不同传输方式时，设置代理的方式也不同。&lt;/p&gt;

&lt;h2 id=&#34;ssh&#34;&gt;SSH&lt;/h2&gt;

&lt;p&gt;当使用SSH协议时，git实际上直接使用ssh命令，所以我们只要给ssh设置好代理就可以了。在~/.ssh/config中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Host github.com
    User                    git
    ProxyCommand            nc -x localhost:1080 %h %p
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参见ssh_config(5)manual&lt;/p&gt;

&lt;h2 id=&#34;http-s&#34;&gt;HTTP(S)&lt;/h2&gt;

&lt;p&gt;git使用&lt;code&gt;libcurl&lt;/code&gt;来处理HTTP和HTTPS，可以通过设置git的&lt;code&gt;http.proxy&lt;/code&gt;选项：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git config --global http.proxy socks5://localhost:1080&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;参见curl(1)的&amp;ndash;proxy选项和git-config(1)中的http.proxy&lt;/p&gt;

&lt;h2 id=&#34;git&#34;&gt;Git&lt;/h2&gt;

&lt;p&gt;当使用git传输协议时，你可以设置git的&lt;code&gt;gitproxy&lt;/code&gt;选项：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git config --global core.gitproxy git-proxy&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这里的git-proxy是任何一个可执行文件，同时它要能接受2个参数，host、port（git服务器的地址和端口）。git-proxy完成代理工作。&lt;/p&gt;

&lt;p&gt;例如这样一个shell脚本：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#!/usr/bin/env bash

nc -x localhost:1080 $1 $2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参见git_config(1)&lt;/p&gt;

&lt;h2 id=&#34;如何判断git使用何种协议&#34;&gt;如何判断git使用何种协议&lt;/h2&gt;

&lt;p&gt;根据git服务器的url就可以看出：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ssh://[user@]host.xz[:port]/path/to/repo.git/&lt;/li&gt;
&lt;li&gt;git://host.xz[:port]/path/to/repo.git/&lt;/li&gt;
&lt;li&gt;http[s]://host.xz[:port]/path/to/repo.git/&lt;/li&gt;
&lt;li&gt;ftp[s]://host.xz[:port]/path/to/repo.git/&lt;/li&gt;
&lt;li&gt;rsync://host.xz/path/to/repo.git/&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于SSH协议，还有一种类似scp的语法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;[user@]host.xz:path/to/repo.git/&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参见git-fetch(1)的GIT URLS&lt;/p&gt;

&lt;h2 id=&#34;nc命令&#34;&gt;nc命令&lt;/h2&gt;

&lt;p&gt;nc(netcat)可以用 -X 指定代理方式：socks4、 sockes5、 HTTPS CONNECT，默认为socks5。 -x 指定代理地址。&lt;/p&gt;

&lt;p&gt;参见nc(1)&lt;/p&gt;

&lt;h3 id=&#34;reference&#34;&gt;reference&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://cms-sw.github.io/tutorial-proxy.html&#34;&gt;Tutorial: how to use git through a proxy&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>python logging</title>
      <link>http://qingyunha.github.com/hugo/post/python-logging/</link>
      <pubDate>Sat, 09 Jul 2016 21:32:25 +0800</pubDate>
      
      <guid>http://qingyunha.github.com/hugo/post/python-logging/</guid>
      <description>&lt;p&gt;日志对程序的调试和问题的发现很有帮助。如何设置合适的日志需要需要一些考虑。&lt;/p&gt;

&lt;p&gt;以python标准库logging为例。&lt;/p&gt;

&lt;p&gt;logging分有多种级别:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;DEBUG&lt;/li&gt;
&lt;li&gt;INFO&lt;/li&gt;
&lt;li&gt;WARNING&lt;/li&gt;
&lt;li&gt;ERROR&lt;/li&gt;
&lt;li&gt;CRITICAL&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一个应用中可以有多个logger对象，比如每个module一个logger。
不同logger对象可以设置不同的级别，只有大于该级别的log事件才会被记录。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>A Web Crawler With asyncio Coroutines</title>
      <link>http://qingyunha.github.com/hugo/translation/crawler/</link>
      <pubDate>Sat, 09 Jul 2016 11:32:25 +0800</pubDate>
      
      <guid>http://qingyunha.github.com/hugo/translation/crawler/</guid>
      <description>

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;经典的计算机科学强调高效的算法，尽可能快地完成计算。但是很多网络程序的时间并不是消耗在计算上，而是在等待许多慢速的连接或者低频事件的发生。这些程序暴露出一个新的挑战：如何高效的等待大量网络事件。一个现代的解决方案是异步I/O。&lt;/p&gt;

&lt;p&gt;这一章我们将实现一个简单的网络爬虫。这个爬虫只是一个原型式的异步应用，因为它等待许多响应而只做少量的计算。一次爬的网页越多，它就能越快的完成任务。如果它为每个动态的请求启动一个线程的话，随着并发请求数量的增加，它会在耗尽套接字之前，耗尽内存或者线程相关的资源。使用异步I/O可以避免这个的问题。&lt;/p&gt;

&lt;p&gt;我们将分三个阶段展示这个例子。首先，我们会实现一个事件循环并用这个事件循环和回调来勾画出一个网络爬虫。它很有效，但是当把它扩展成更复杂的问题时，就会导致无法管理的混乱代码。然后，由于Python的协程不仅有效而且可扩展，我们将用Python的生成器函数实现一个简单的协程。在最后一个阶段，我们将使用Python标准库&amp;rdquo;asyncio&amp;rdquo;中功能完整的协程和异步队列完成这个网络爬虫。&lt;/p&gt;

&lt;h2 id=&#34;the-task&#34;&gt;The Task&lt;/h2&gt;

&lt;p&gt;网络爬虫寻找并下载一个网站上的所有网页，也许还会把它们存档，为它们建立索引。从根URL开始，它获取每个网页，解析出没有遇到过的链接加到队列中。当网页没有未见到过的链接并且队列为空时，它便停止运行。&lt;/p&gt;

&lt;p&gt;我们可以通过同时下载大量的网页来加快这一过程。当爬虫发现新的链接，它使用一个新的套接字并行的处理这个新链接，解析响应，添加新链接到队列。当并发很大时，可能会导致性能下降，所以我们会限制并发的数量，在队列保留那些未处理的链接，直到一些正在执行的任务完成。&lt;/p&gt;

&lt;h2 id=&#34;the-traditional-approach&#34;&gt;The Traditional Approach&lt;/h2&gt;

&lt;p&gt;怎么使一个爬虫并发？传统的做法是创建一个线程池，每个线程使用一个套接字在一段时间内负责一个网页的下载。比如，下载xkcd.com网站的一个网页：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def fetch(url):
    sock = socket.socket()
    sock.connect((&#39;xkcd.com&#39;, 80))
    request = &#39;GET {} HTTP/1.0\r\nHost: xkcd.com\r\n\r\n&#39;.format(url)
    sock.send(request.encode(&#39;ascii&#39;))
    response = b&#39;&#39;
    chunk = sock.recv(4096)
    while chunk:
        response += chunk
        chunk = sock.recv(4096)
    
    # Page is now downloaded.
    links = parse_links(response)
    q.add(links)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;套接字操作默认是阻塞的：当一个线程调用一个类似&lt;code&gt;connect&lt;/code&gt;和&lt;code&gt;recv&lt;/code&gt;方法时，它会阻塞，直到操作完成.&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:15&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:15&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;因此，为了同一时间内下载多个网页，我们需要很多线程。一个复杂的应用会通过线程池保持空闲的线程来分摊创建线程的开销。同样的做法也适用于套接字，使用连接池。&lt;/p&gt;

&lt;p&gt;到目前为止，线程是昂贵的，操作系统对一个进程，一个用户，一台机器能使用线程做了不同的硬性限制。在Jesse系统中，一个Python线程需要50K的内存，开启上万个线程会失败。每个线程的开销和系统的限制就是这种方式的瓶颈所在。&lt;/p&gt;

&lt;p&gt;在Dan Kegel那一篇很有影响力的文章&amp;rdquo;The C10K problem&amp;rdquo;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:8&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:8&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;中，它提出多线程方式在I/O并发上的局限性。他在开始写道，&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;是时候网络服务器要同时处理成千上万的客户啦，你不这样认为么？毕竟，现在网络是个很大的地方。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Kegel在1999年创造出&amp;rdquo;C10K&amp;rdquo;术语。一万个连接在今天看来还是可接受的，但是问题依然存在，只不过大小不同。回到那时候，对于C10K问题，每个连接启一个线程是不切实际的。现在这个限制已经成指数级增长。确实，我们的玩具网络爬虫使用线程也可以工作的很好。但是，对于有着千万级连接的大规模应用来说，限制依然存在：会消耗掉所有线程，即使套接字还够用。那么我们该如何解决这个问题？&lt;/p&gt;

&lt;h2 id=&#34;async&#34;&gt;Async&lt;/h2&gt;

&lt;p&gt;异步I/O框架在一个线程中完成并发操作。让我们看看这是怎么做到的。&lt;/p&gt;

&lt;p&gt;异步框架使用*非阻塞*套接字。异步爬虫中，我们在发起到服务器的连接前把套接字设为非阻塞：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;sock = socket.socket()
sock.setblocking(False)
try:
    sock.connect((&#39;xkcd.com&#39;, 80))
except BlockingIOError:
    pass
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对一个非阻塞套接字调用&lt;code&gt;connect&lt;/code&gt;方法会立即抛出异常，即使它正常工作。这个异常模拟了底层C语言函数的行为，它把&lt;code&gt;errno&lt;/code&gt;设置为&lt;code&gt;EINPROGRESS&lt;/code&gt;,告诉你操作已经开始。&lt;/p&gt;

&lt;p&gt;现在我们的爬虫需要一种知道连接何时建立的方法，这样它才能发送HTTP请求。我们可以简单地使用循环来重试：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;request = &#39;GET {} HTTP/1.0\r\nHost: xkcd.com\r\n\r\n&#39;.format(url)
encoded = request.encode(&#39;ascii&#39;)

while True:
    try:
        sock.send(encoded)
        break  # Done.
    except OSError as e:
        pass

print(&#39;sent&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种方法不仅消耗CPU，也不能有效的等待*多个*套接字。在远古时代，BSD Unix的解决方法是&lt;code&gt;select&lt;/code&gt;,一个C函数，它在一个或一组非阻塞套接字上等待事件发生。现在，互联网应用大量连接的需求，导致&lt;code&gt;select&lt;/code&gt;被&lt;code&gt;poll&lt;/code&gt;代替，以及BSD的&lt;code&gt;kqueue&lt;/code&gt;和Linux的&lt;code&gt;epoll&lt;/code&gt;。它们的API和&lt;code&gt;select&lt;/code&gt;相似，但在大数量的连接中也能有较好的性能。&lt;/p&gt;

&lt;p&gt;Python 3.4的&lt;code&gt;DefaultSelector&lt;/code&gt;使用你系统上最好的类&lt;code&gt;select&lt;/code&gt;函数。去注册一个网络I/O事件，我们创建一个非阻塞套接字，并使用默认的selector注册。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from selectors import DefaultSelector, EVENT_WRITE

selector = DefaultSelector()

sock = socket.socket()
sock.setblocking(False)
try:
    sock.connect((&#39;xkcd.com&#39;, 80))
except BlockingIOError:
    pass

def connected():
    selector.unregister(sock.fileno())
    print(&#39;connected!&#39;)

selector.register(sock.fileno(), EVENT_WRITE, connected)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们不理会这个伪造的错误，调用&lt;code&gt;selector.register&lt;/code&gt;，传递套接字文件描述符，一个表示我们想要监听什么事件的常量。为了当连接建立时收到提醒，我们使用&lt;code&gt;EVENT_WRITE&lt;/code&gt;:它表示什么时候这个套接字可写。我们还传递了一个Python函数，&lt;code&gt;connected&lt;/code&gt;,当对应事件发生时被调用。这样的函数被称为*回调*。&lt;/p&gt;

&lt;p&gt;我们在一个循环中处理I/O提醒，随着selector接收到它们。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def loop():
    while True:
        events = selector.select()
        for event_key, event_mask in events:
            callback = event_key.data
            callback()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;connected&lt;/code&gt;回调函数被保存在&lt;code&gt;event_key.data&lt;/code&gt;中，一旦这个非阻塞套接字建立连接，它就会被取出来执行。&lt;/p&gt;

&lt;p&gt;不像我们前面那个快速重试的循环，这里的&lt;code&gt;select&lt;/code&gt;调用会阻塞，等待下一个I/O事件，接着执行等待这个事件的回调函数。&lt;/p&gt;

&lt;p&gt;到目前为止我们展现了什么？我们展示了如何开始一个I/O操作和当操作准备好时调用回调函数。异步*框架*，它在单线程中执行并发操作，建立在两个功能之上，非阻塞套接字和事件循环。&lt;/p&gt;

&lt;h2 id=&#34;programming-with-callbacks&#34;&gt;Programming With Callbacks&lt;/h2&gt;

&lt;p&gt;用我们刚刚建立的异步框架，怎么才能完成一个网络爬虫？即使是一个简单的网页下载程序也是很难写的。&lt;/p&gt;

&lt;p&gt;首先，我们有一个未获取的URL集合，和一个已经解析过的URL集合。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;urls_todo = set([&#39;/&#39;])
seen_urls = set([&#39;/&#39;])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这两个集合加在一起就是所有的URL。用&amp;rdquo;/&amp;ldquo;初始化它们。&lt;/p&gt;

&lt;p&gt;获取一个网页需要一系列的回调。在套接字连接建立时&lt;code&gt;connected&lt;/code&gt;回调触发，它向服务器发送一个GET请求。但是它要等待响应，所以我们需要注册另一个回调函数，当回调被调用，它也不能一次读取完整的请求，所以，需要再一次注册，如此反复。&lt;/p&gt;

&lt;p&gt;让我们把这些回调放在一个&lt;code&gt;Fetcher&lt;/code&gt;对象中，它需要一个URL，一个套接字，还需要一个地方保存返回的字节：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Fetcher:
    def __init__(self, url):
        self.response = b&#39;&#39;  # Empty array of bytes.
        self.url = url
        self.sock = None
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们的入口点在&lt;code&gt;Fetcher.fetch&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;    # Method on Fetcher class.
    def fetch(self):
        self.sock = socket.socket()
        self.sock.setblocking(False)
        try:
            self.sock.connect((&#39;xkcd.com&#39;, 80))
        except BlockingIOError:
            pass
            
        # Register next callback.
        selector.register(self.sock.fileno(),
                          EVENT_WRITE,
                          self.connected)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;fetch&lt;/code&gt;方法从连接一个套接字开始。但是要注意这个方法在连接建立前就返回了。它必须返回到事件循环中等待连接建立。为了理解为什么要要这样，假设我们程序的整体结构如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Begin fetching http://xkcd.com/353/
fetcher = Fetcher(&#39;/353/&#39;)
fetcher.fetch()

while True:
    events = selector.select()
    for event_key, event_mask in events:
        callback = event_key.data
        callback(event_key, event_mask)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所有的事件提醒都在事件循环中的&lt;code&gt;select&lt;/code&gt;函数后处理。所以&lt;code&gt;fetch&lt;/code&gt;必须把控制权交给事件循环。这样我们的程序才能知道什么时候连接已建立，接着循环调用&lt;code&gt;connected&lt;/code&gt;回调，它已经在&lt;code&gt;fetch&lt;/code&gt;方法中注册过。&lt;/p&gt;

&lt;p&gt;这里是我们&lt;code&gt;connected&lt;/code&gt;方法的实现：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;    # Method on Fetcher class.
    def connected(self, key, mask):
        print(&#39;connected!&#39;)
        selector.unregister(key.fd)
        request = &#39;GET {} HTTP/1.0\r\nHost: xkcd.com\r\n\r\n&#39;.format(self.url)
        self.sock.send(request.encode(&#39;ascii&#39;))
        
        # Register the next callback.
        selector.register(key.fd,
                          EVENT_READ,
                          self.read_response)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个方法发送一个GET请求。一个真正的应用会检查&lt;code&gt;send&lt;/code&gt;的返回值，以防所有的信息没能一次发送出去。但是我们的请求很小，应用也不复杂。它只是简单的调用&lt;code&gt;send&lt;/code&gt;，然后等待响应。当然，它必须注册另一个回调并把控制权交给事件循环。接下来也是最后一个回调函数&lt;code&gt;read_response&lt;/code&gt;，它处理服务器的响应：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;    # Method on Fetcher class.
    def read_response(self, key, mask):
        global stopped

        chunk = self.sock.recv(4096)  # 4k chunk size.
        if chunk:
            self.response += chunk
        else:
            selector.unregister(key.fd)  # Done reading.
            links = self.parse_links()
            
            # Python set-logic:
            for link in links.difference(seen_urls):
                urls_todo.add(link)
                Fetcher(link).fetch()  # &amp;lt;- New Fetcher.

            seen_urls.update(links)
            urls_todo.remove(self.url)
            if not urls_todo:
                stopped = True
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个回调在每次selector发现套接字*可读*时被调用，可读有两种情况：套接字接受到数据或它被关闭。&lt;/p&gt;

&lt;p&gt;这个回调函数从套接字读取4K数据。如果没有4k，那么有多少读多少。如果比4K多，&lt;code&gt;chunk&lt;/code&gt;只包4K数据并且这个套接字保持可读，这样在事件循环的下一个周期，会在次回到这个回调函数。当响应完成时，服务器关闭这个套接字，&lt;code&gt;chunk&lt;/code&gt;为空。&lt;/p&gt;

&lt;p&gt;没有展示的&lt;code&gt;parse_links&lt;/code&gt;方法，它返回一个URL集合。我们为每个新的URL启动一个fetcher。注意一个使用异步回调方式编程的好处：我们不需要为共享数据加锁，比如我们往&lt;code&gt;seen_urls&lt;/code&gt;增加新链接时。这是一种非抢占式的多任务，它不会在我们代码中的任意一个地方中断。&lt;/p&gt;

&lt;p&gt;我们增加了一个全局变量&lt;code&gt;stopped&lt;/code&gt;，用它来控制这个循环：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;stopped = False

def loop():
    while not stopped:
        events = selector.select()
        for event_key, event_mask in events:
            callback = event_key.data
            callback()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一旦所有的网页被下载下来，fetcher停止这个事件循环，程序退出。&lt;/p&gt;

&lt;p&gt;这个例子让异步编程的一个问题明显的暴露出来：意大利面代码。&lt;/p&gt;

&lt;p&gt;我们需要某种方式来表达一串计算和I/O操作，并且能够调度多个这样的操作让他们并发的执行。但是，没有线程你不能把这一串操作写在一个函数中：当函数开始一个I/O操作，它明确的把未来所需的状态保存下来，然后返回。你需要考虑如何写这个状态保存的代码。&lt;/p&gt;

&lt;p&gt;让我们来解释下这到底是什么意思。考虑在线程中使用通常的阻塞套接字来获取一个网页时是多么简单。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Blocking version.
def fetch(url):
    sock = socket.socket()
    sock.connect((&#39;xkcd.com&#39;, 80))
    request = &#39;GET {} HTTP/1.0\r\nHost: xkcd.com\r\n\r\n&#39;.format(url)
    sock.send(request.encode(&#39;ascii&#39;))
    response = b&#39;&#39;
    chunk = sock.recv(4096)
    while chunk:
        response += chunk
        chunk = sock.recv(4096)
    
    # Page is now downloaded.
    links = parse_links(response)
    q.add(links)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在一个套接字操作和下一个操作之间这个函数到底记住了什么？它有一个套接字，一个URL和一个可增长的&lt;code&gt;response&lt;/code&gt;。运行在线程中的函数使用编程语言的基本功能，栈中的局部变量来保存临时的状态。这样的函数有一个&amp;rdquo;continuation&amp;rdquo;&amp;mdash;-在I/O结束后它要执行的代码。运行时通过线程的指令指针来记住这个continuation。你不必考虑怎么在I/O操作后恢复局部变量和这个continuation。语言本身的特性帮你解决。&lt;/p&gt;

&lt;p&gt;但是用一个基于回调的异步框架，这些语言特性不能提供一点帮助。当等待I/O操作时，一个函数必须明确的保存它的状态，因为它会在I/O操作完成之前返回并清除栈帧。为了在我们基于回调的例子中代替局部变量，我们把&lt;code&gt;sock&lt;/code&gt;和&lt;code&gt;response&lt;/code&gt;作为Fetcher实例&lt;code&gt;self&lt;/code&gt;属性。为了代替指令指针，它通过注册&lt;code&gt;connnected&lt;/code&gt;和&lt;code&gt;read_response&lt;/code&gt;回调来保存continuation。随着应用功能的增长，我们手动保存回调的复杂性也会增加。如此繁复的记账式工作会让编码者感到头痛。&lt;/p&gt;

&lt;p&gt;更糟糕的是，当我们的回调函数抛出异常会发生什么？假设我们没有写好&lt;code&gt;parse_links&lt;/code&gt;方法，它在解析HTML时抛出异常：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Traceback (most recent call last):
  File &amp;quot;loop-with-callbacks.py&amp;quot;, line 111, in &amp;lt;module&amp;gt;
    loop()
  File &amp;quot;loop-with-callbacks.py&amp;quot;, line 106, in loop
    callback(event_key, event_mask)
  File &amp;quot;loop-with-callbacks.py&amp;quot;, line 51, in read_response
    links = self.parse_links()
  File &amp;quot;loop-with-callbacks.py&amp;quot;, line 67, in parse_links
    raise Exception(&#39;parse error&#39;)
Exception: parse error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个堆栈回溯只能显示出事件循环调用了一个回调。我们不知道是什么导致了这个错误。这条链的两边都被破坏：不知道从哪来也不知到哪去。这种丢失上下文的现象被称为&amp;rdquo;stack ripping&amp;rdquo;，它还会阻止我们为回调链设置异常处理。&lt;/p&gt;

&lt;p&gt;所以，除了关于多线程和异步那个更高效的争议，还有一个关于这两者之间的争论，谁更容易出错。如果在同步上出现失误，线程更容易出现数据竞争的问题，而回调因为&amp;rdquo;stack ripping&amp;rdquo;问题而非常难于调试。&lt;/p&gt;

&lt;h2 id=&#34;coroutines&#34;&gt;Coroutines&lt;/h2&gt;

&lt;p&gt;还记得我们对你许下的承诺么？我们可以写出这样的异步代码，它既有回调方式的高效，也有多线程代码的简洁。这个结合是同过一种称为协程的模式来实现的。使用Python3.4标准库asyncio和一个叫&amp;rdquo;aiohttp&amp;rdquo;的包，在协程中获取一个网页是非常直接的&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:10&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:10&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;    @asyncio.coroutine
    def fetch(self, url):
        response = yield from self.session.get(url)
        body = yield from response.read()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它也是可扩展的。在Jesse系统上，与每个线程50k内存相比，一个Python协程只需要3k内存。Python很容易就可以启动上千个协程。&lt;/p&gt;

&lt;p&gt;协程的概念可以追溯到计算机科学的远古时代，它很简单，一个可以暂停和恢复的子过程。线程是被操作系统控制的抢占式多任务，而协程是可合作的，它们自己选择什么时候暂停去执行下一个协程。&lt;/p&gt;

&lt;p&gt;有很多协程的实现。甚至在Python中也有几种。Python3.4标准库asyncio中的协程，它是建立在生成器，一个Future类和&amp;rdquo;yield from&amp;rdquo;语句之上。从Python3.5开始，协程变成了语言本身的特性。然而，理解Python3.4中这个通过语言原有功能实现的协程，是我们处理Python3.5中原生协程的基础。&lt;/p&gt;

&lt;h2 id=&#34;how-python-generators-work&#34;&gt;How Python Generators Work&lt;/h2&gt;

&lt;p&gt;在你理解生成器之前，你需要知道普通的Python函数是怎么工作的。当一个函数调用一个子过程，这个被调用函数获得控制权。直到它返回或者有异常发生，才把控制权交给调用者：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; def foo():
...     bar()
...
&amp;gt;&amp;gt;&amp;gt; def bar():
...     pass
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;标准的Python解释器是C语言写的。一个Python函数被调用对应的C函数是&lt;code&gt;PyEval_EvalFrameEx&lt;/code&gt;。它获得一个Python栈帧结构并在这个栈帧的上下文中执行Python字节码。这里是&lt;code&gt;foo&lt;/code&gt;的字节码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; import dis
&amp;gt;&amp;gt;&amp;gt; dis.dis(foo)
  2           0 LOAD_GLOBAL              0 (bar)
              3 CALL_FUNCTION            0 (0 positional, 0 keyword pair)
              6 POP_TOP
              7 LOAD_CONST               0 (None)
             10 RETURN_VALUE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;foo&lt;/code&gt;函数在它栈中加载&lt;code&gt;bar&lt;/code&gt;并调用它，然后把&lt;code&gt;bar&lt;/code&gt;的返回值从栈中弹出，加载&lt;code&gt;None&lt;/code&gt;值并返回。&lt;/p&gt;

&lt;p&gt;当&lt;code&gt;PyEval_EvalFrameEx&lt;/code&gt;遇到&lt;code&gt;CALL_FUNCTION&lt;/code&gt;字节码时，它会创建一个新的栈帧，并用这个栈帧递归的调用&lt;code&gt;PyEval_EvalFrameEx&lt;/code&gt;来执行&lt;code&gt;bar&lt;/code&gt;函数。&lt;/p&gt;

&lt;p&gt;图&lt;/p&gt;

&lt;p&gt;非常重要的一点是，Python的栈帧在堆中分配！Python解释器是一个标准的C程序，所以他的栈帧是正常的栈帧。但是Python的栈帧是在堆中处理。这意味着Python栈帧在函数调用结束后依然可以存在。我们在&lt;code&gt;bar&lt;/code&gt;函数中保存当前的栈帧，交互式的看看这种现象：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; import inspect
&amp;gt;&amp;gt;&amp;gt; frame = None
&amp;gt;&amp;gt;&amp;gt; def foo():
...     bar()
...
&amp;gt;&amp;gt;&amp;gt; def bar():
...     global frame
...     frame = inspect.currentframe()
...
&amp;gt;&amp;gt;&amp;gt; foo()
&amp;gt;&amp;gt;&amp;gt; # The frame was executing the code for &#39;bar&#39;.
&amp;gt;&amp;gt;&amp;gt; frame.f_code.co_name
&#39;bar&#39;
&amp;gt;&amp;gt;&amp;gt; # Its back pointer refers to the frame for &#39;foo&#39;.
&amp;gt;&amp;gt;&amp;gt; caller_frame = frame.f_back
&amp;gt;&amp;gt;&amp;gt; caller_frame.f_code.co_name
&#39;foo&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在该说Python生成器了，它使用同样构件&amp;ndash;code object和栈帧&amp;ndash;去完成一个不可思议的任务。&lt;/p&gt;

&lt;p&gt;这是一个生成器函数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; def gen_fn():
...     result = yield 1
...     print(&#39;result of yield: {}&#39;.format(result))
...     result2 = yield 2
...     print(&#39;result of 2nd yield: {}&#39;.format(result2))
...     return &#39;done&#39;
...     
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在Python把&lt;code&gt;gen_fn&lt;/code&gt;编译成字节码的过程中，一旦它看到&lt;code&gt;yield&lt;/code&gt;语句就知道这是一个生成器函数而不是普通的函数。它就会设置一个标志来记住这个事实：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; # The generator flag is bit position 5.
&amp;gt;&amp;gt;&amp;gt; generator_bit = 1 &amp;lt;&amp;lt; 5
&amp;gt;&amp;gt;&amp;gt; bool(gen_fn.__code__.co_flags &amp;amp; generator_bit)
True
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当你调用一个生成器函数，Python看到这个标志，就不会运行它而是创建一个生成器：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; gen = gen_fn()
&amp;gt;&amp;gt;&amp;gt; type(gen)
&amp;lt;class &#39;generator&#39;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Python生成器封装了一个栈帧和函数体代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; gen.gi_code.co_name
&#39;gen_fn&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所有通过调用&lt;code&gt;gen_fn&lt;/code&gt;的生成器指向同一段代码，但都有各自的栈帧。这些栈帧不再任何一个C函数栈中，而是在堆空间中等待被使用：&lt;/p&gt;

&lt;p&gt;图&lt;/p&gt;

&lt;p&gt;栈帧中有一个指向最后执行指令的指针。初始化为-1，意味着它没开始运行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; gen.gi_frame.f_lasti
-1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当我们调用&lt;code&gt;send&lt;/code&gt;时，生成器一直运行到第一个&lt;code&gt;yield&lt;/code&gt;语句处停止。并且&lt;code&gt;send&lt;/code&gt;返回1，yield语句后的表达式的值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; gen.send(None)
1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在生成器的指令指针是3，字节码一共有56个字节：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; gen.gi_frame.f_lasti
3
&amp;gt;&amp;gt;&amp;gt; len(gen.gi_code.co_code)
56
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个生成器可以在任何时候，任何函数中恢复运行，因为它的栈帧并不在真正的栈中，而是堆中。在调用链中它的位置也是不确定的，它不必遵循普通函数先进后出的顺序。它像云一样自由。&lt;/p&gt;

&lt;p&gt;我们可以传递一个&lt;code&gt;hello&lt;/code&gt;给生成器，它会成为yield语句的结果，并且生成器运行到第二个yield语句处。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; gen.send(&#39;hello&#39;)
result of yield: hello
2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在栈帧中包含局部变量&lt;code&gt;result&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; gen.gi_frame.f_locals
{&#39;result&#39;: &#39;hello&#39;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其它从&lt;code&gt;gen_fn&lt;/code&gt;创建的生成器有着它自己的栈帧和局部变量。&lt;/p&gt;

&lt;p&gt;当我们在一次调用&lt;code&gt;send&lt;/code&gt;，生成器从第二个yield开始运行，以抛出一个特殊的&lt;code&gt;StopIteration&lt;/code&gt;异常为结束。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; gen.send(&#39;goodbye&#39;)
result of 2nd yield: goodbye
Traceback (most recent call last):
  File &amp;quot;&amp;lt;input&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt;
StopIteration: done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个异常有一个值&amp;rdquo;done&amp;rdquo;，它就是生成器的返回值。&lt;/p&gt;

&lt;h2 id=&#34;building-coroutines-with-generators&#34;&gt;Building Coroutines With Generators&lt;/h2&gt;

&lt;p&gt;所以生成器可以暂停，可以给它一个值让它恢复，并且它还有一个返回值。这些特性看起来很适合去建立一个不使用回调的异步编程模型。我们想创造一个协程：一个在程序中可以和其他过程合作调度的过程。我们的协程将会是标准库&lt;code&gt;asyncio&lt;/code&gt;中协程的一个简化版本，我们将使用生成器，futures和&lt;code&gt;yield from&lt;/code&gt;语句。&lt;/p&gt;

&lt;p&gt;首先，我们需要一种方法去代表协程需要等待的未来事件。一个简化的版本是：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Future:
    def __init__(self):
        self.result = None
        self._callbacks = []

    def add_done_callback(self, fn):
        self._callbacks.append(fn)

    def set_result(self, result):
        self.result = result
        for fn in self._callbacks:
            fn(self)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一个future初始化为未解决的，它同过调用&lt;code&gt;set_result&lt;/code&gt;来解决。&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:12&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:12&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;让我们用futures和协程来改写我们的fetcher。我们之前用回调写的fetcher如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Fetcher:
    def fetch(self):
        self.sock = socket.socket()
        self.sock.setblocking(False)
        try:
            self.sock.connect((&#39;xkcd.com&#39;, 80))
        except BlockingIOError:
            pass
        selector.register(self.sock.fileno(),
                          EVENT_WRITE,
                          self.connected)

    def connected(self, key, mask):
        print(&#39;connected!&#39;)
        # And so on....
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;fetch&lt;/code&gt;方法开始连接一个套接字，然后注册&lt;code&gt;connected&lt;/code&gt;回调函数，它会在套接字建立连接后调用。现在我们使用协程把这两步合并：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;    def fetch(self):
        sock = socket.socket()
        sock.setblocking(False)
        try:
            sock.connect((&#39;xkcd.com&#39;, 80))
        except BlockingIOError:
            pass

        f = Future()

        def on_connected():
            f.set_result(None)

        selector.register(sock.fileno(),
                          EVENT_WRITE,
                          on_connected)
        yield f
        selector.unregister(sock.fileno())
        print(&#39;connected!&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在，&lt;code&gt;fetch&lt;/code&gt;是一个生成器，因为他有一个&lt;code&gt;yield&lt;/code&gt;语句。我们创建一个未决的future，然后yield它，暂停执行直到套接字连接建立。内函数&lt;code&gt;on_connected&lt;/code&gt;解决这个future。&lt;/p&gt;

&lt;p&gt;但是当future被解决，谁来恢复这个生成器？我们需要一个协程驱动器。让我们叫它&lt;code&gt;task&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Task:
    def __init__(self, coro):
        self.coro = coro
        f = Future()
        f.set_result(None)
        self.step(f)

    def step(self, future):
        try:
            next_future = self.coro.send(future.result)
        except StopIteration:
            return

        next_future.add_done_callback(self.step)

# Begin fetching http://xkcd.com/353/
fetcher = Fetcher(&#39;/353/&#39;)
Task(fetcher.fetch())

loop()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;task通过传递一个None值给&lt;code&gt;fetch&lt;/code&gt;来启动它。&lt;code&gt;fetch&lt;/code&gt;运行到它yeild一个future，这个future被task捕获作为&lt;code&gt;next_future&lt;/code&gt;。当套接字连接建立，事件循环运行回调函数&lt;code&gt;on_connected&lt;/code&gt;，这里future被解决，&lt;code&gt;step&lt;/code&gt;被调用，生成器恢复运行。&lt;/p&gt;

&lt;h2 id=&#34;factoring-coroutines-with-yield-from&#34;&gt;Factoring Coroutines With &lt;code&gt;yield from&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;一旦套接字连接建立，我们就可以发送HTTP请求，然后读取服务器响应。不再需要哪些分散在各处的回调函数，我们把它们放在同一个生成器函数中：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;    def fetch(self):
        # ... connection logic from above, then:
        sock.send(request.encode(&#39;ascii&#39;))

        while True:
            f = Future()

            def on_readable():
                f.set_result(sock.recv(4096))

            selector.register(sock.fileno(),
                              EVENT_READ,
                              on_readable)
            chunk = yield f
            selector.unregister(sock.fileno())
            if chunk:
                self.response += chunk
            else:
                # Done reading.
                break
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从套接字中读取所有信息的代码看起来很通用。我们能不把它提取成一个子过程？现在该Python3的&lt;code&gt;yield from&lt;/code&gt;登场了。它能让一个生成器委托另一个生成器。&lt;/p&gt;

&lt;p&gt;让我们先回到原来那个简单的生成器：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; def gen_fn():
...     result = yield 1
...     print(&#39;result of yield: {}&#39;.format(result))
...     result2 = yield 2
...     print(&#39;result of 2nd yield: {}&#39;.format(result2))
...     return &#39;done&#39;
...     
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了从其他生成器调用这个生成器，我们使用&lt;code&gt;yield from&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; # Generator function:
&amp;gt;&amp;gt;&amp;gt; def caller_fn():
...     gen = gen_fn()
...     rv = yield from gen
...     print(&#39;return value of yield-from: {}&#39;
...           .format(rv))
...
&amp;gt;&amp;gt;&amp;gt; # Make a generator from the
&amp;gt;&amp;gt;&amp;gt; # generator function.
&amp;gt;&amp;gt;&amp;gt; caller = caller_fn()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个&lt;code&gt;caller&lt;/code&gt;的行为的和它委派的生成器表现的完全一致：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; caller.send(None)
1
&amp;gt;&amp;gt;&amp;gt; caller.gi_frame.f_lasti
15
&amp;gt;&amp;gt;&amp;gt; caller.send(&#39;hello&#39;)
result of yield: hello
2
&amp;gt;&amp;gt;&amp;gt; caller.gi_frame.f_lasti  # Hasn&#39;t advanced.
15
&amp;gt;&amp;gt;&amp;gt; caller.send(&#39;goodbye&#39;)
result of 2nd yield: goodbye
return value of yield-from: done
Traceback (most recent call last):
  File &amp;quot;&amp;lt;input&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt;
StopIteration
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意到&lt;code&gt;caller&lt;/code&gt;的指令指针保持15不变，就是&lt;code&gt;yield from&lt;/code&gt;的地方，即使内部的生成器从一个yield语句运行到下一个yield，它始终不变。&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:13&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:13&#34;&gt;5&lt;/a&gt;&lt;/sup&gt;从&lt;code&gt;caller&lt;/code&gt;外部来看，我们无法分辨yield出的值是来自&lt;code&gt;caller&lt;/code&gt;还是它委派的生成器。而从&lt;code&gt;gen&lt;/code&gt;内部来看，我们也不能分辨传给它的值是来自&lt;code&gt;caller&lt;/code&gt;还是&lt;code&gt;caller&lt;/code&gt;的外面。&lt;code&gt;yield from&lt;/code&gt;是一个光滑的管道，值通过它进出&lt;code&gt;gen&lt;/code&gt;，一直到&lt;code&gt;gen&lt;/code&gt;结束。&lt;/p&gt;

&lt;p&gt;协程可以用&lt;code&gt;yield from&lt;/code&gt;把工作委派给子协程，还可以接受子协程的返回值。注意到上面的&lt;code&gt;caller&lt;/code&gt;打印出&amp;rdquo;return value of yield-from: done&amp;rdquo;。当&lt;code&gt;gen&lt;/code&gt;完成后，它的返回值成为&lt;code&gt;caller&lt;/code&gt;中&lt;code&gt;yield from&lt;/code&gt;语句的值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;    rv = yield from gen
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们批评过基于回调的异步编程模式，其中最大的不满是关于&lt;code&gt;stack ripping&lt;/code&gt;：当一个回调抛出异常，它的堆栈回溯通常是毫无用处的。它只显示出事件循环运行了它，而没有说为什么。那么协程怎么样？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; def gen_fn():
...     raise Exception(&#39;my error&#39;)
&amp;gt;&amp;gt;&amp;gt; caller = caller_fn()
&amp;gt;&amp;gt;&amp;gt; caller.send(None)
Traceback (most recent call last):
  File &amp;quot;&amp;lt;input&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt;
  File &amp;quot;&amp;lt;input&amp;gt;&amp;quot;, line 3, in caller_fn
  File &amp;quot;&amp;lt;input&amp;gt;&amp;quot;, line 2, in gen_fn
Exception: my error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这还是比较有用的，当异常抛出时，堆栈回溯显示出&lt;code&gt;caller_fn&lt;/code&gt;委派了&lt;code&gt;gen_fn&lt;/code&gt;。令人更欣慰的是，你可以像正常函数一样使用异常处理：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; def gen_fn():
...     yield 1
...     raise Exception(&#39;uh oh&#39;)
...
&amp;gt;&amp;gt;&amp;gt; def caller_fn():
...     try:
...         yield from gen_fn()
...     except Exception as exc:
...         print(&#39;caught {}&#39;.format(exc))
...
&amp;gt;&amp;gt;&amp;gt; caller = caller_fn()
&amp;gt;&amp;gt;&amp;gt; caller.send(None)
1
&amp;gt;&amp;gt;&amp;gt; caller.send(&#39;hello&#39;)
caught uh oh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以我们可以像提取子过程一样提取子协程。让我们从fetcher中提取一些有用的子协程。我们先写一个可以读一块数据的协程&lt;code&gt;read&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def read(sock):
    f = Future()

    def on_readable():
        f.set_result(sock.recv(4096))

    selector.register(sock.fileno(), EVENT_READ, on_readable)
    chunk = yield f  # Read one chunk.
    selector.unregister(sock.fileno())
    return chunk
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在&lt;code&gt;read&lt;/code&gt;的基础上，&lt;code&gt;read_all&lt;/code&gt;协程读取整个信息：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def read_all(sock):
    response = []
    # Read whole response.
    chunk = yield from read(sock)
    while chunk:
        response.append(chunk)
        chunk = yield from read(sock)

    return b&#39;&#39;.join(response)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你换个角度看，它们看起来就像在做阻塞I/O的普通函数一样。但是事实上，&lt;code&gt;read&lt;/code&gt;和&lt;code&gt;read_all&lt;/code&gt;都是协程。yield from&lt;code&gt;read&lt;/code&gt;暂停&lt;code&gt;read_all&lt;/code&gt;直到I/O操作完成。当&lt;code&gt;read_all&lt;/code&gt;暂停时，事件循环正在做其它的工作等待其他的I/O操作。&lt;code&gt;read&lt;/code&gt;在下次循环中完成I/O操作时，&lt;code&gt;read_all&lt;/code&gt;恢复运行。&lt;/p&gt;

&lt;p&gt;现在，&lt;code&gt;fetch&lt;/code&gt;可以直接调用&lt;code&gt;read_all&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Fetcher:
    def fetch(self):
         # ... connection logic from above, then:
        sock.send(request.encode(&#39;ascii&#39;))
        self.response = yield from read_all(sock)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;神奇的是，Task类不需要做任何改变，它像以前一样驱动&lt;code&gt;fetch&lt;/code&gt;协程：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;Task(fetcher.fetch())
loop()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当&lt;code&gt;read&lt;/code&gt;yield一个future时，task从&lt;code&gt;yield from&lt;/code&gt;管道中接受它，就像直接从&lt;code&gt;fetch&lt;/code&gt;接受一样。当循环解决一个future时，task把它的结果送给&lt;code&gt;fetch&lt;/code&gt;,通过管道，&lt;code&gt;read&lt;/code&gt;接受到这个值，这完全就像task直接驱动&lt;code&gt;read&lt;/code&gt;一样：&lt;/p&gt;

&lt;p&gt;图&lt;/p&gt;

&lt;p&gt;亲爱的读者，我们已经完成了对asyncio协程探索。我们深入观察了生成器的机制，实现了简单的future和task。我们指出协程是如何利用两个世界的优点：比线程高效，比回调清晰。当然真正的asyncio比我们这个简化版本要复杂的多。真正的框架需要处理zero-copyI/0，公平调度，异常处理和其他大量特性。&lt;/p&gt;

&lt;p&gt;使用asyncio编写协程代码比你现在看到的要简单的多。在前面的代码中，我们从基本原理去实现协程，所以你看到了回调，task和future，甚至非阻塞套接字和&lt;code&gt;select&lt;/code&gt;调用。但是当用asyncio编写应用，这些都不会出现在你的代码中。我们承诺过，你可以像这样下载一个网页：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;    @asyncio.coroutine
    def fetch(self, url):
        response = yield from self.session.get(url)
        body = yield from response.read()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对我们的探索还满意么？回到我们原始的任务：使用asyncio写一个网络爬虫。&lt;/p&gt;

&lt;h2 id=&#34;coordinating-coroutines&#34;&gt;Coordinating Coroutines&lt;/h2&gt;

&lt;p&gt;我们从描述爬虫如何工作开始。现在是时候用asynio去实现它了。&lt;/p&gt;

&lt;p&gt;我们爬虫从获取第一个网页开始，解析出链接并把它们加到队列中。此后它开始傲游整个网站，并发的获取网页。倒是由于客户端和服务端的限制，我们希望有一个最大数目的worker。任何时候一个worker完成一个网页的获取，它应该立即从队列中取出下一个链接。我们会遇到没有事干的时候，所以worker必须能够暂停。一旦又有worker获取一个有很多链接的网页，队列会突增，暂停的worker立马被唤醒。最后，当任务完成后我们的程序必须能退出。&lt;/p&gt;

&lt;p&gt;假如你的worker是线程，怎样去描述你的算法？我们可以使用Python标准库中的同步队列。每次有新的一项加入，队列增加它的tasks计数器。线程worker完成一个任务后调用&lt;code&gt;task_done&lt;/code&gt;。主线程阻塞在&lt;code&gt;Queue.join&lt;/code&gt;，直到tasks计数器与&lt;code&gt;task_done&lt;/code&gt;调用次数相匹配，然后退出。&lt;/p&gt;

&lt;p&gt;通过个一asynio队列，协程使用和线程一样的模式来实现。首先我们导入它&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:6&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:6&#34;&gt;6&lt;/a&gt;&lt;/sup&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;try:
    from asyncio import JoinableQueue as Queue
except ImportError:
    # In Python 3.5, asyncio.JoinableQueue is
    # merged into Queue.
    from asyncio import Queue
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们把worker的共享状态收集在一个crawler类中,主要的逻辑写在&lt;code&gt;crawl&lt;/code&gt;方法中。我们在一个协程中启动&lt;code&gt;crawl&lt;/code&gt;,运行asyncio的事件循环直到&lt;code&gt;crawl&lt;/code&gt;完成：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;loop = asyncio.get_event_loop()

crawler = crawling.Crawler(&#39;http://xkcd.com&#39;,
                           max_redirect=10)

loop.run_until_complete(crawler.crawl())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;crawler用一个跟URL和最大重定向数来初始化，它把&lt;code&gt;(URL, max_redirect&lt;/code&gt;)序对放入队列中。(为什么要这样做，敬请期待)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Crawler:
    def __init__(self, root_url, max_redirect):
        self.max_tasks = 10
        self.max_redirect = max_redirect
        self.q = Queue()
        self.seen_urls = set()
        
        # aiohttp&#39;s ClientSession does connection pooling and
        # HTTP keep-alives for us.
        self.session = aiohttp.ClientSession(loop=loop)
        
        # Put (URL, max_redirect) in the queue.
        self.q.put((root_url, self.max_redirect))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在队列中未完成的任务数是1。回到我们的主程序，启动事件循环和&lt;code&gt;crawl&lt;/code&gt;方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;loop.run_until_complete(crawler.crawl())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;crawl&lt;/code&gt;协程唤起workers。它像一个主线程：阻塞在&lt;code&gt;join&lt;/code&gt;上直到所有任务完成，同时workers在后台运行。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;    @asyncio.coroutine
    def crawl(self):
        &amp;quot;&amp;quot;&amp;quot;Run the crawler until all work is done.&amp;quot;&amp;quot;&amp;quot;
        workers = [asyncio.Task(self.work())
                   for _ in range(self.max_tasks)]

        # When all work is done, exit.
        yield from self.q.join()
        for w in workers:
            w.cancel()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果worker是线程，可能我们不会一次把它们全部创建出来。为了避免创建线程的昂贵代价，通常一个线程池会按需增长。但是协程很便宜，我们简单的把他们全部创建出来。&lt;/p&gt;

&lt;p&gt;怎么关闭这个&lt;code&gt;crawler&lt;/code&gt;很有趣。当&lt;code&gt;join&lt;/code&gt;完成，worker存活但是被暂停：他们等待更多的URL。所以主协程在退出之前清除它们。否则Python解释器关闭调用所有对象的析构函数，活着的worker叫喊到：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ERROR:asyncio:Task was destroyed but it is pending!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;cancel&lt;/code&gt;又是如何工作的呢？生成器还有一个我们还没介绍的特点。你可以从外部抛一个异常给它：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; gen = gen_fn()
&amp;gt;&amp;gt;&amp;gt; gen.send(None)  # Start the generator as usual.
1
&amp;gt;&amp;gt;&amp;gt; gen.throw(Exception(&#39;error&#39;))
Traceback (most recent call last):
  File &amp;quot;&amp;lt;input&amp;gt;&amp;quot;, line 3, in &amp;lt;module&amp;gt;
  File &amp;quot;&amp;lt;input&amp;gt;&amp;quot;, line 2, in gen_fn
Exception: error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;生成器被&lt;code&gt;throw&lt;/code&gt;恢复，但是他现在抛出一个异常。如何生成器没有捕获异常的代码，这个异常被传递到顶层。所以注销一个协程：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;    # Method of Task class.
    def cancel(self):
        self.coro.throw(CancelledError)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;任何时候生成器在&lt;code&gt;yield from&lt;/code&gt;语句暂停，被恢复并且抛出一个异常。我们在task的&lt;code&gt;step&lt;/code&gt;方法中处理撤销。&lt;/p&gt;

&lt;p&gt;现在worker直到他被注销了，所以当它被销毁时,它不再抱怨。&lt;/p&gt;

&lt;p&gt;一旦&lt;code&gt;crawl&lt;/code&gt;注销了worker，它就退出。同时事件循环看见这个协程结束了，也就退出l。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;loop.run_until_complete(crawler.crawl())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;crawl&lt;/code&gt;方法包含了所有主协程需要做的事。而worker则完成了从队列中获取URL，获取网页，解析它们得到新的链接。每个worker独立的运行&lt;code&gt;worker&lt;/code&gt;协程：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;    @asyncio.coroutine
    def work(self):
        while True:
            url, max_redirect = yield from self.q.get()

            # Download page and add new links to self.q.
            yield from self.fetch(url, max_redirect)
            self.q.task_done()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Python看见这段代码包含&lt;code&gt;yield from&lt;/code&gt;语句，就把它编译成生成器函数。所以在&lt;code&gt;crawl&lt;/code&gt;方法中，我们调用了10次&lt;code&gt;self.work&lt;/code&gt;,但并没有真正执行，它仅仅创建了10个生成器对象并把它们包装成Task对象。task接收生成器yield的future，通过调用send方法，future的结果做为send的参数，来驱动它。由于生成器有自己的栈帧，它们可以独立运行，独立的局部变量和指令指针。&lt;/p&gt;

&lt;p&gt;worker使用队列来协调， 等待新的URL：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;    url, max_redirect = yield from self.q.get()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;队列的&lt;code&gt;get&lt;/code&gt;方法也是一个协程，它一直暂停到有新的URL进入队列。&lt;/p&gt;

&lt;p&gt;碰巧，这也是最后crawl停止时，协程暂停的地方。当主协程注销worker时，从协程的角度，&lt;code&gt;yield from&lt;/code&gt;抛出&lt;code&gt;CancelledError&lt;/code&gt;结束了它在循环中的最后旅程。&lt;/p&gt;

&lt;p&gt;worker获取一个网页，解析链接，把新的链接放入队列中，接着调用&lt;code&gt;task_done&lt;/code&gt;减小计数器。最终一个worker遇到一个没有新链接的网页，并且队列里也没有任务，这次&lt;code&gt;task_done&lt;/code&gt;的调用使计数器减为0，而&lt;code&gt;crawl&lt;/code&gt;正阻塞在&lt;code&gt;join&lt;/code&gt;方法上，现在它就可以结束了。&lt;/p&gt;

&lt;p&gt;我们承诺过要解释为什么队列中要使用序对，像这样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# URL to fetch, and the number of redirects left.
(&#39;http://xkcd.com/353&#39;, 10)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;新的URL的重定向次数是10。获取一个特别的URL会重定向一个新的位置。我们减小重定向次数，并把新的URL放入队列中。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# URL with a trailing slash. Nine redirects left.
(&#39;http://xkcd.com/353/&#39;, 9)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们使用的&lt;code&gt;aiohttp&lt;/code&gt;默认的会重定向返回最终的结果。但是，我们告诉它不要这样做，爬虫自己处理重定向。所以它可以合并那些目的相同的重定向路径：如果我们已经看到一个URL，说明它已经从其他的地方走过这条路了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;    @asyncio.coroutine
    def fetch(self, url, max_redirect):
        # Handle redirects ourselves.
        response = yield from self.session.get(
            url, allow_redirects=False)

        try:
            if is_redirect(response):
                if max_redirect &amp;gt; 0:
                    next_url = response.headers[&#39;location&#39;]
                    if next_url in self.seen_urls:
                        # We have been down this path before.
                        return
    
                    # Remember we have seen this URL.
                    self.seen_urls.add(next_url)
                    
                    # Follow the redirect. One less redirect remains.
                    self.q.put_nowait((next_url, max_redirect - 1))
             else:
                 links = yield from self.parse_links(response)
                 # Python set-logic:
                 for link in links.difference(self.seen_urls):
                    self.q.put_nowait((link, self.max_redirect))
                self.seen_urls.update(links)
        finally:
            # Return connection to pool.
            yield from response.release()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果这是多进程代码，就有可能遇到讨厌的竞争条件。比如，一个work检查一个链接是否在&lt;code&gt;seen_urls&lt;/code&gt;中，如果没有它就把这个链接加到队列中并把它放到&lt;code&gt;seen_urls&lt;/code&gt;中。如果它在这两步操作之间被中断，而另一个work解析到相同的链接，发现它并没有出现在&lt;code&gt;seen_urls&lt;/code&gt;中就把它加入队列中。这导致同样的链接在队列中出现两次，做了重复的工作和错误的统计。&lt;/p&gt;

&lt;p&gt;然而，一个协程只在&lt;code&gt;yield from&lt;/code&gt;是才会被中断。这是协程比多线程少遇到竞争条件的关键。多线程必须获得锁来明确的进入一个临界区，否则它就是可中断的。而Python的协程默认是不会被中断的，只有它yield主动放弃控制权。&lt;/p&gt;

&lt;p&gt;我们不再需要在用回调方式时的fetcher类了。这个类只是不高效回调的一个变通方法：在等待I/O时，它需要一个存储状态的地方，因为局部变量并不能在函数调用间保留。倒是&lt;code&gt;fetch&lt;/code&gt;协程可以像普通函数一样用局部变量保存它的状态，所以我们不再需要一个类。&lt;/p&gt;

&lt;p&gt;当&lt;code&gt;fetch&lt;/code&gt;完成对服务器回应的处理，它返回到调用它的work。work调用&lt;code&gt;task_done&lt;/code&gt;,接着从队列中取出一个URL。&lt;/p&gt;

&lt;p&gt;当&lt;code&gt;fetch&lt;/code&gt;把新的链接放入队列中，它增加未完成的任务计数器。主协程在等待&lt;code&gt;q.join&lt;/code&gt;。而当没有新的链接并且这是队列中最后一个URL，work调用&lt;code&gt;task_done&lt;/code&gt;，任务计数器变为0，主协程从&lt;code&gt;join&lt;/code&gt;中退出。&lt;/p&gt;

&lt;p&gt;与work和主协程一起工作的队列代码像这样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Queue:
    def __init__(self):
        self._join_future = Future()
        self._unfinished_tasks = 0
        # ... other initialization ...
    
    def put_nowait(self, item):
        self._unfinished_tasks += 1
        # ... store the item ...

    def task_done(self):
        self._unfinished_tasks -= 1
        if self._unfinished_tasks == 0:
            self._join_future.set_result(None)

    @asyncio.coroutine
    def join(self):
        if self._unfinished_tasks &amp;gt; 0:
            yield from self._join_future
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;主协程&lt;code&gt;crawl&lt;/code&gt;yield from&lt;code&gt;join&lt;/code&gt;。所以当最后一个workd把计数器减为0，它告诉&lt;code&gt;crawl&lt;/code&gt;恢复运行。&lt;/p&gt;

&lt;p&gt;旅程快要结束了。我们的程序从&lt;code&gt;crawl&lt;/code&gt;调用开始：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;loop.run_until_complete(self.crawler.crawl())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;程序如何结束？因为&lt;code&gt;crawl&lt;/code&gt;是一个生成器函数。调用它返回一个生成器。为了驱动它，asyncio把它包装成一个task：&lt;/p&gt;

&lt;p&gt;class EventLoop:
    def run_until_complete(self, coro):
        &amp;ldquo;&amp;rdquo;&amp;ldquo;Run until the coroutine is done.&amp;rdquo;&amp;ldquo;&amp;rdquo;
        task = Task(coro)
        task.add_done_callback(stop_callback)
        try:
            self.run_forever()
        except StopError:
            pass&lt;/p&gt;

&lt;p&gt;class StopError(BaseException):
    &amp;ldquo;&amp;rdquo;&amp;ldquo;Raised to stop the event loop.&amp;rdquo;&amp;ldquo;&amp;rdquo;&lt;/p&gt;

&lt;p&gt;def stop_callback(future):
    raise StopError&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
当这个任务完成，它抛出`StopError`, 事件循环把这个异常当作正常退出的信号。

但是，task的`add_done_callbock`和`result`方法又是什么呢？你可能认为task就像一个future，不错，你的直觉是对的。我们必须承认一个向你隐藏的细节，task是future。

```python
class Task(Future):
    &amp;quot;&amp;quot;&amp;quot;A coroutine wrapped in a Future.&amp;quot;&amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通常，一个future被别人调用&lt;code&gt;set_result&lt;/code&gt;。但是task，当协程结束时，它自己解决自己。记得我们解释过当Python生成器返回时，它抛出一个特殊的&lt;code&gt;StopIteration&lt;/code&gt;异常：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;    # Method of class Task.
    def step(self, future):
        try:
            next_future = self.coro.send(future.result)
        except CancelledError:
            self.cancelled = True
            return
        except StopIteration as exc:

            # Task resolves itself with coro&#39;s return
            # value.
            self.set_result(exc.value)
            return

        next_future.add_done_callback(self.step)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以当事件循环调用&lt;code&gt;task.add_done_callback(stop_callback)&lt;/code&gt;，它就准备被这个task结束。在看一次&lt;code&gt;run_until_complete&lt;/code&gt;；&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;    # Method of event loop.
    def run_until_complete(self, coro):
        task = Task(coro)
        task.add_done_callback(stop_callback)
        try:
            self.run_forever()
        except StopError:
            pass
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当task捕获&lt;code&gt;StopIteration&lt;/code&gt;并解决自己，这个回调重循环中抛出&lt;code&gt;StopError&lt;/code&gt;。循环结束调用栈回到&lt;code&gt;run_until_complete&lt;/code&gt;。我们的程序结束。&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;现代的程序越来越多是I/O密集型而不是CPU密集型。对于这样的程序，Python的线程和不合适：全局锁阻止真正的并行计算，并且抢占切换也导致他们更容易出现竞争。异步通常是正确的选择。但是随着基于回调的异步代码增加，它会变得非常混乱。协程是一个更整洁的替代者。它们自然的重构成子过程，有健全的异常处理和栈追溯。&lt;/p&gt;

&lt;p&gt;如果我们换个角度看&lt;code&gt;yield from&lt;/code&gt;语句，一个协程看起来像一个传统的线程。甚至我们采用金典的多线程模式编程，不需要重新发明。因此，与回调相比，协程更适合有经验的多线程的编码者。&lt;/p&gt;

&lt;p&gt;但是当我们打开眼睛关注&lt;code&gt;yield from&lt;/code&gt;语句，我们能看到协程放弃控制权的标志点。不像多线程，协程展示出我们的代码哪里可以被中断哪里不能。在Glyph Lefkowitz富有启发性的文章&amp;rdquo;Unyielding&amp;rdquo;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:4&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:4&#34;&gt;7&lt;/a&gt;&lt;/sup&gt;：&amp;rdquo;线程让局部推理变得困难，然而局部推理可能是软件开发中最重要的事&amp;rdquo;。然而，明确的yield，让&amp;rdquo;通过子过程本身而不是整个系统理解它的行为(应此，正确性)&amp;ldquo;成为可能。&lt;/p&gt;

&lt;p&gt;这章写于Python和异步的复兴时期。你刚学到的基于生成器的的协程，在2014年发布在Python 3.4的&amp;rdquo;asyncio&amp;rdquo;模块。2015年9月，Python 3.5发布，协程成为语言的一部分。这个原生的协程通过&amp;rdquo;async def&amp;rdquo;来声明, 使用&amp;rdquo;await&amp;rdquo;而不是&amp;rdquo;yield from&amp;rdquo;委托一个协程或者等待Future。&lt;/p&gt;

&lt;p&gt;除了这些优点，核心的思想不变。Python新的原生协程与生成器只是在语法上不同，工作原理非常相似。事实上，在Python解释器中它们公用同一个实现方法。Task，Future和事件循环扮演这在asynico中同样的角色。&lt;/p&gt;

&lt;p&gt;你已经知道asyncio协程是如何工作的了，现在你可以忘记大部分的细节。这些机制隐藏在一个整洁的接口下。但是你对这基本原理的理解能让你在现代异步环境下正确而高效的编写代码。&lt;/p&gt;

&lt;p&gt;&lt;latex&gt;
&lt;/latex&gt;
&lt;markdown&gt;
&lt;/markdown&gt;&lt;/p&gt;

&lt;p&gt;&lt;markdown&gt;
&lt;/markdown&gt;
&lt;latex&gt;
&lt;/latex&gt;&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:15&#34;&gt;Even calls to &lt;code&gt;send&lt;/code&gt; can block, if the recipient is slow to acknowledge outstanding messages and the system&amp;rsquo;s buffer of outgoing data is full.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:15&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:8&#34;&gt;&lt;a href=&#34;http://www.kegel.com/c10k.html&#34;&gt;http://www.kegel.com/c10k.html&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:8&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:10&#34;&gt;The &lt;code&gt;@asyncio.coroutine&lt;/code&gt; decorator is not magical. In fact, if it decorates a generator function and the &lt;code&gt;PYTHONASYNCIODEBUG&lt;/code&gt; environment variable is not set, the decorator does practically nothing. It just sets an attribute, &lt;code&gt;_is_coroutine&lt;/code&gt;, for the convenience of other parts of the framework. It is possible to use asyncio with bare generators not decorated with &lt;code&gt;@asyncio.coroutine&lt;/code&gt; at all.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:10&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:12&#34;&gt;This future has many deficiencies. For example, once this future is resolved, a coroutine that yields it should resume immediately instead of pausing, but with our code it does not. See asyncio&amp;rsquo;s Future class for a complete implementation.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:12&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:13&#34;&gt;In fact, this is exactly how &amp;ldquo;yield from&amp;rdquo; works in CPython. A function increments its instruction pointer before executing each statement. But after the outer generator executes &amp;ldquo;yield from&amp;rdquo;, it subtracts 1 from its instruction pointer to keep itself pinned at the &amp;ldquo;yield from&amp;rdquo; statement. Then it yields to &lt;em&gt;its&lt;/em&gt; caller. The cycle repeats until the inner generator throws &lt;code&gt;StopIteration&lt;/code&gt;, at which point the outer generator finally allows itself to advance to the next instruction.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:13&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:6&#34;&gt;&lt;a href=&#34;https://docs.python.org/3/library/asyncio-sync.html&#34;&gt;https://docs.python.org/3/library/asyncio-sync.html&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:6&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:4&#34;&gt;&lt;a href=&#34;https://glyph.twistedmatrix.com/2014/02/unyielding.html&#34;&gt;https://glyph.twistedmatrix.com/2014/02/unyielding.html&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:4&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>A Python Interpreter Written in Python</title>
      <link>http://qingyunha.github.com/hugo/translation/python-interpreter/</link>
      <pubDate>Mon, 09 May 2016 11:32:25 +0800</pubDate>
      
      <guid>http://qingyunha.github.com/hugo/translation/python-interpreter/</guid>
      <description>

&lt;p&gt;&lt;em&gt;Allison是Dropbox的工程师，在那里她维护着世界上最大的由Python客户组成的网络。在Dropbox之前，她是Recurse Center的导师, 曾在纽约写作。在北美的PyCon做过关于Python内部机制的演讲，并且她喜欢奇怪的bugs。她的博客地址是&lt;a href=&#34;http://akaptur.com&#34;&gt;akaptur.com&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;Byterun是一个用Python实现的Python解释器。随着我在Byterun上的工作，我惊讶并很高兴地的发现，这个Python解释器的基础结构可以满足500行的限制。在这一章我们会搞清楚这个解释器的结构，给你足够的知识探索下去。我们的目标不是向你展示解释器的每个细节&amp;mdash;像编程和计算机科学其他有趣的领域一样，你可能会投入几年的时间去搞清楚这个主题。&lt;/p&gt;

&lt;p&gt;Byterun是Ned Batchelder和我完成的，建立在Paul Swartz的工作之上。它的结构和主要的Python实现（CPython）差不多，所以理解Byterun会帮助你理解大多数解释器特别是CPython解释器。（如果你不知道你用的是什么Python，那么很可能它就是CPython）。尽管Byterun很小，但它能执行大多数简单的Python程序。&lt;/p&gt;

&lt;h3 id=&#34;a-python-interpreter&#34;&gt;A Python Interpreter&lt;/h3&gt;

&lt;p&gt;在开始之前，让我们缩小一下“Pyhton解释器”的意思。在讨论Python的时候，“解释器”这个词可以用在很多不同的地方。有的时候解释器指的是REPL，当你在命令行下敲下&lt;code&gt;python&lt;/code&gt;时所得到的交互式环境。有时候人们会相互替代的使用Python解释器和Python来说明执行Python代码的这一过程。在本章，“解释器”有一个更精确的意思：执行Python程序过程中的最后一步。&lt;/p&gt;

&lt;p&gt;在解释器接手之前，Python会执行其他3个步骤：词法分析，语法解析和编译。这三步合起来把源代码转换成&lt;em&gt;code object&lt;/em&gt;,它包含着解释器可以理解的指令。而解释器的工作就是解释code object中的指令。&lt;/p&gt;

&lt;p&gt;你可能很奇怪执行Python代码会有编译这一步。Python通常被称为解释型语言，就像Ruby，Perl一样，它们和编译型语言相对，比如C，Rust。然而，这里的术语并不是它看起来的那样精确。大多数解释型语言包括Python，确实会有编译这一步。而Python被称为解释型的原因是相对于编译型语言，它在编译这一步的工作相对较少（解释器做相对多的工作）。在这章后面你会看到，Python的编译器比C语言编译器需要更少的关于程序行为的信息。&lt;/p&gt;

&lt;h3 id=&#34;a-python-python-interpreter&#34;&gt;A Python Python Interpreter&lt;/h3&gt;

&lt;p&gt;Byterun是一个用Python写的Python解释器，这点可能让你感到奇怪，但没有比用C语言写C语言编译器更奇怪。（事实上，广泛使用的gcc编译器就是用C语言本身写的）你可以用几乎的任何语言写一个Python解释器。&lt;/p&gt;

&lt;p&gt;用Python写Python既有优点又有缺点。最大的缺点就是速度：用Byterun执行代码要比用CPython执行慢的多，CPython解释器是用C语言实现的并做了优化。然而Byterun是为了学习而设计的，所以速度对我们不重要。使用Python最大优点是我们可以*仅仅*实现解释器，而不用担心Python运行时的部分，特别是对象系统。比如当Byterun需要创建一个类时，它就会回退到“真正”的Python。另外一个优势是Byterun很容易理解，部分原因是它是用高级语言写的（Python！）（另外我们不会对解释器做优化 &amp;mdash; 再一次，清晰和简单比速度更重要）&lt;/p&gt;

&lt;h2 id=&#34;building-an-interpreter&#34;&gt;Building an Interpreter&lt;/h2&gt;

&lt;p&gt;在我们考察Byterun代码之前，我们需要一些对解释器结构的高层次视角。Python解释器是如何工作的？&lt;/p&gt;

&lt;p&gt;Python解释器是一个&lt;em&gt;虚拟机&lt;/em&gt;,模拟真实计算机的软件。我们这个虚拟机是栈机器，它用几个栈来完成操作（与之相对的是寄存器机器，它从特定的内存地址读写数据）。&lt;/p&gt;

&lt;p&gt;Python解释器是一个_字节码解释器_：它的输入是一些命令集合称作_字节码_。当你写Python代码时，词法分析器，语法解析器和编译器生成code object让解释器去操作。每个code object都包含一个要被执行的指令集合 &amp;mdash; 它就是字节码 &amp;mdash; 另外还有一些解释器需要的信息。字节码是Python代码的一个_中间层表示_：它以一种解释器可以理解的方式来表示源代码。这和汇编语言作为C语言和机器语言的中间表示很类似。&lt;/p&gt;

&lt;h3 id=&#34;a-tiny-interpreter&#34;&gt;A Tiny Interpreter&lt;/h3&gt;

&lt;p&gt;为了让说明更具体，让我们从一个非常小的解释器开始。它只能计算两个数的和，只能理解三个指令。它执行的所有代码只是这三个指令的不同组合。下面就是这三个指令：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;LOAD_VALUE&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ADD_TWO_VALUES&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PRINT_ANSWER&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们不关心词法，语法和编译，所以我们也不在乎这些指令是如何产生的。你可以想象，你写下&lt;code&gt;7 + 5&lt;/code&gt;，然后一个编译器为你生成那三个指令的组合。如果你有一个合适的编译器，你甚至可以用Lisp的语法来写，只要它能生成相同的指令。&lt;/p&gt;

&lt;p&gt;假设&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;7 + 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;生成这样的指令集：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;what_to_execute = {
    &amp;quot;instructions&amp;quot;: [(&amp;quot;LOAD_VALUE&amp;quot;, 0),  # the first number
                     (&amp;quot;LOAD_VALUE&amp;quot;, 1),  # the second number
                     (&amp;quot;ADD_TWO_VALUES&amp;quot;, None),
                     (&amp;quot;PRINT_ANSWER&amp;quot;, None)],
    &amp;quot;numbers&amp;quot;: [7, 5] }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Python解释器是一个_栈机器_，所以它必须通过操作栈来完成这个加法。(\aosafigref{500l.interpreter.stackmachine}.)解释器先执行第一条指令，&lt;code&gt;LOAD_VALUE&lt;/code&gt;，把第一个数压到栈中。接着它把第二个数也压到栈中。然后，第三条指令，&lt;code&gt;ADD_TWO_VALUES&lt;/code&gt;,先把两个数从栈中弹出，加起来，再把结果压入栈中。最后一步，把结果弹出并输出。&lt;/p&gt;

&lt;p&gt;\aosafigure[240pt]{interpreter-images/interpreter-stack.png}{A stack machine}{500l.interpreter.stackmachine}&lt;/p&gt;

&lt;p&gt;&lt;code&gt;LOAD_VALUE&lt;/code&gt;这条指令告诉解释器把一个数压入栈中，但指令本身并没有指明这个数是多少。指令需要一个额外的信息告诉解释器去哪里找到这个数。所以我们的指令集有两个部分：指令本身和一个常量列表。（在Python中，字节码就是我们称为的“指令”，而解释器执行的是_code object_。）&lt;/p&gt;

&lt;p&gt;为什么不把数字直接嵌入指令之中？想象一下，如果我们加的不是数字，而是字符串。我们可不想把字符串这样的东西加到指令中，因为它可以有任意的长度。另外，我们这种设计也意味着我们只需要对象的一份拷贝，比如这个加法 &lt;code&gt;7 + 7&lt;/code&gt;, 现在常量表 &lt;code&gt;&amp;quot;numbers&amp;quot;&lt;/code&gt;只需包含一个&lt;code&gt;7&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;你可能会想为什么会需要除了&lt;code&gt;ADD_TWO_VALUES&lt;/code&gt;之外的指令。的确，对于我们两个数加法，这个例子是有点人为制作的意思。然而，这个指令却是建造更复杂程序的轮子。比如，就我们目前定义的三个指令，只要给出正确的指令组合，我们可以做三个数的加法，或者任意个数的加法。同时，栈提供了一个清晰的方法去跟踪解释器的状态，这为我们增长的复杂性提供了支持。&lt;/p&gt;

&lt;p&gt;现在让我们来完成我们的解释器。解释器对象需要一个栈，它可以用一个列表来表示。它还需要一个方法来描述怎样执行每条指令。比如，&lt;code&gt;LOAD_VALUE&lt;/code&gt;会把一个值压入栈中。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Interpreter:
    def __init__(self):
        self.stack = []

    def LOAD_VALUE(self, number):
        self.stack.append(number)

    def PRINT_ANSWER(self):
        answer = self.stack.pop()
        print(answer)

    def ADD_TWO_VALUES(self):
        first_num = self.stack.pop()
        second_num = self.stack.pop()
        total = first_num + second_num
        self.stack.append(total)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这三个方法完成了解释器所理解的三条指令。但解释器还需要一样东西：一个能把所有东西结合在一起并执行的方法。这个方法就叫做&lt;code&gt;run_code&lt;/code&gt;, 它把我们前面定义的字典结构&lt;code&gt;what-to-execute&lt;/code&gt;作为参数，循环执行里面的每条指令，如何指令有参数，处理参数，然后调用解释器对象中相应的方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;    def run_code(self, what_to_execute):
        instructions = what_to_execute[&amp;quot;instructions&amp;quot;]
        numbers = what_to_execute[&amp;quot;numbers&amp;quot;]
        for each_step in instructions:
            instruction, argument = each_step
            if instruction == &amp;quot;LOAD_VALUE&amp;quot;:
                number = numbers[argument]
                self.LOAD_VALUE(number)
            elif instruction == &amp;quot;ADD_TWO_VALUES&amp;quot;:
                self.ADD_TWO_VALUES()
            elif instruction == &amp;quot;PRINT_ANSWER&amp;quot;:
                self.PRINT_ANSWER()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了测试，我们创建一个解释器对象，然后用前面定义的 7 + 5 的指令集来调用&lt;code&gt;run_code&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;    interpreter = Interpreter()
    interpreter.run_code(what_to_execute)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;显然，它会输出12&lt;/p&gt;

&lt;p&gt;尽管我们的解释器功能受限，但这个加法过程几乎和真正的Python解释器是一样的。这里，我们还有几点要注意。&lt;/p&gt;

&lt;p&gt;首先，一些指令需要参数。在真正的Python bytecode中，大概有一半的指令有参数。像我们的例子一样，参数和指令打包在一起。注意_指令_的参数和传递给对应方法的参数是不同的。&lt;/p&gt;

&lt;p&gt;第二，指令&lt;code&gt;ADD_TWO_VALUES&lt;/code&gt;不需要任何参数，它从解释器栈中弹出所需的值。这正是以栈为基础的解释器的特点。&lt;/p&gt;

&lt;p&gt;记得我们说过只要给出合适的指令集，不需要对解释器做任何改变，我们就能做多个数的加法。考虑下面的指令集，你觉得会发生什么？如果你有一个合适的编译器，什么代码才能编译出下面的指令集？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;    what_to_execute = {
        &amp;quot;instructions&amp;quot;: [(&amp;quot;LOAD_VALUE&amp;quot;, 0),
                         (&amp;quot;LOAD_VALUE&amp;quot;, 1),
                         (&amp;quot;ADD_TWO_VALUES&amp;quot;, None),
                         (&amp;quot;LOAD_VALUE&amp;quot;, 2),
                         (&amp;quot;ADD_TWO_VALUES&amp;quot;, None),
                         (&amp;quot;PRINT_ANSWER&amp;quot;, None)],
        &amp;quot;numbers&amp;quot;: [7, 5, 8] }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从这点出发，我们开始看到这种结构的可扩展性：我们可以通过向解释器对象增加方法来描述更多的操作（只要有一个编译器能为我们生成组织良好的指令集）。&lt;/p&gt;

&lt;h3 id=&#34;variables&#34;&gt;Variables&lt;/h3&gt;

&lt;p&gt;接下来给我们的解释器增加变量的支持。我们需要一个保存变量值的指令，&lt;code&gt;STORE_NAME&lt;/code&gt;;一个取变量值的指令&lt;code&gt;LOAD_NAME&lt;/code&gt;;和一个变量到值的映射关系。目前，我们会忽略命名空间和作用域，所以我们可以把变量和值的映射直接存储在解释器对象中。最后，我们要保证&lt;code&gt;what_to_execute&lt;/code&gt;除了一个常量列表，还要有个变量名字的列表。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; def s():
...     a = 1
...     b = 2
...     print(a + b)
# a friendly compiler transforms `s` into:
    what_to_execute = {
        &amp;quot;instructions&amp;quot;: [(&amp;quot;LOAD_VALUE&amp;quot;, 0),
                         (&amp;quot;STORE_NAME&amp;quot;, 0),
                         (&amp;quot;LOAD_VALUE&amp;quot;, 1),
                         (&amp;quot;STORE_NAME&amp;quot;, 1),
                         (&amp;quot;LOAD_NAME&amp;quot;, 0),
                         (&amp;quot;LOAD_NAME&amp;quot;, 1),
                         (&amp;quot;ADD_TWO_VALUES&amp;quot;, None),
                         (&amp;quot;PRINT_ANSWER&amp;quot;, None)],
        &amp;quot;numbers&amp;quot;: [1, 2],
        &amp;quot;names&amp;quot;:   [&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;] }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们的新的的实现在下面。为了跟踪哪名字绑定到那个值，我们在&lt;code&gt;__init__&lt;/code&gt;方法中增加一个&lt;code&gt;environment&lt;/code&gt;字典。我们也增加了&lt;code&gt;STORE_NAME&lt;/code&gt;和&lt;code&gt;LOAD_NAME&lt;/code&gt;方法，它们获得变量名，然后从&lt;code&gt;environment&lt;/code&gt;字典中设置或取出这个变量值。&lt;/p&gt;

&lt;p&gt;现在指令参数就有两个不同的意思，它可能是&lt;code&gt;numbers&lt;/code&gt;列表的索引，也可能是&lt;code&gt;names&lt;/code&gt;列表的索引。解释器通过检查所执行的指令就能知道是那种参数。而我们打破这种逻辑 ，把指令和它所用何种参数的映射关系放在另一个单独的方法中。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Interpreter:
    def __init__(self):
        self.stack = []
        self.environment = {}

    def STORE_NAME(self, name):
        val = self.stack.pop()
        self.environment[name] = val

    def LOAD_NAME(self, name):
        val = self.environment[name]
        self.stack.append(val)

    def parse_argument(self, instruction, argument, what_to_execute):
        &amp;quot;&amp;quot;&amp;quot; Understand what the argument to each instruction means.&amp;quot;&amp;quot;&amp;quot;
        numbers = [&amp;quot;LOAD_VALUE&amp;quot;]
        names = [&amp;quot;LOAD_NAME&amp;quot;, &amp;quot;STORE_NAME&amp;quot;]

        if instruction in numbers:
            argument = what_to_execute[&amp;quot;numbers&amp;quot;][argument]
        elif instruction in names:
            argument = what_to_execute[&amp;quot;names&amp;quot;][argument]

        return argument

    def run_code(self, what_to_execute):
        instructions = what_to_execute[&amp;quot;instructions&amp;quot;]
        for each_step in instructions:
            instruction, argument = each_step
            argument = self.parse_argument(instruction, argument, what_to_execute)

            if instruction == &amp;quot;LOAD_VALUE&amp;quot;:
                self.LOAD_VALUE(argument)
            elif instruction == &amp;quot;ADD_TWO_VALUES&amp;quot;:
                self.ADD_TWO_VALUES()
            elif instruction == &amp;quot;PRINT_ANSWER&amp;quot;:
                self.PRINT_ANSWER()
            elif instruction == &amp;quot;STORE_NAME&amp;quot;:
                self.STORE_NAME(argument)
            elif instruction == &amp;quot;LOAD_NAME&amp;quot;:
                self.LOAD_NAME(argument)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;仅仅五个指令，&lt;code&gt;run_code&lt;/code&gt;这个方法已经开始变得冗长了。如果保持这种结构，那么每条指令都需要一个&lt;code&gt;if&lt;/code&gt;分支。这里，我们要利用Python的动态方法查找。我们总会给一个称为&lt;code&gt;FOO&lt;/code&gt;的指令定义一个名为&lt;code&gt;FOO&lt;/code&gt;的方法，这样我们就可用Python的&lt;code&gt;getattr&lt;/code&gt;函数在运行时动态查找方法，而不用这个大大的分支结构。&lt;code&gt;run_code&lt;/code&gt;方法现在是这样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;    def execute(self, what_to_execute):
        instructions = what_to_execute[&amp;quot;instructions&amp;quot;]
        for each_step in instructions:
            instruction, argument = each_step
            argument = self.parse_argument(instruction, argument, what_to_execute)
            bytecode_method = getattr(self, instruction)
            if argument is None:
                bytecode_method()
            else:
                bytecode_method(argument)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;real-python-bytecode&#34;&gt;Real Python Bytecode&lt;/h2&gt;

&lt;p&gt;现在，放弃我们的小指令集，去看看真正的Python字节码。字节码的结构和我们的小解释器的指令集差不多，除了字节码用一个字节而不是一个名字来指示这条指令。为了理解它的结构，我们将考察一个函数的字节码。考虑下面这个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; def cond():
...     x = 3
...     if x &amp;lt; 5:
...         return &#39;yes&#39;
...     else:
...         return &#39;no&#39;
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Python在运行时会暴露一大批内部信息，并且我们可以通过REPL直接访问这些信息。对于函数对象&lt;code&gt;cond&lt;/code&gt;，&lt;code&gt;cond.__code__&lt;/code&gt;是与其关联的code object，而&lt;code&gt;cond.__code__.co_code&lt;/code&gt;就是它的字节码。当你写Python代码时，你永远也不会想直接使用这些属性，但是这可以让我们做出各种恶作剧，同时也可以看看内部机制。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; cond.__code__.co_code  # the bytecode as raw bytes
b&#39;d\x01\x00}\x00\x00|\x00\x00d\x02\x00k\x00\x00r\x16\x00d\x03\x00Sd\x04\x00Sd\x00
   \x00S&#39;
&amp;gt;&amp;gt;&amp;gt; list(cond.__code__.co_code)  # the bytecode as numbers
[100, 1, 0, 125, 0, 0, 124, 0, 0, 100, 2, 0, 107, 0, 0, 114, 22, 0, 100, 3, 0, 83, 
 100, 4, 0, 83, 100, 0, 0, 83]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当我们直接输出这个字节码，它看起来完全无法理解 &amp;mdash; 唯一我们了解的是它是一串字节。很幸运，我们有一个很强大的工具可以用：Python标准库中的&lt;code&gt;dis&lt;/code&gt;模块。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;dis&lt;/code&gt;是一个字节码反汇编器。反汇编器以为机器而写的底层代码作为输入，比如汇编代码和字节码，然后以人类可读的方式输出。当我们运行&lt;code&gt;dis.dis&lt;/code&gt;, 它输出每个字节码的解释。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; dis.dis(cond)
  2           0 LOAD_CONST               1 (3)
              3 STORE_FAST               0 (x)

  3           6 LOAD_FAST                0 (x)
              9 LOAD_CONST               2 (5)
             12 COMPARE_OP               0 (&amp;lt;)
             15 POP_JUMP_IF_FALSE       22

  4          18 LOAD_CONST               3 (&#39;yes&#39;)
             21 RETURN_VALUE

  6     &amp;gt;&amp;gt;   22 LOAD_CONST               4 (&#39;no&#39;)
             25 RETURN_VALUE
             26 LOAD_CONST               0 (None)
             29 RETURN_VALUE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这些都是什么意思？让我们以第一条指令&lt;code&gt;LOAD_CONST&lt;/code&gt;为例子。第一列的数字（&lt;code&gt;2&lt;/code&gt;）表示对应源代码的行数。第二列的数字是字节码的索引，告诉我们指令&lt;code&gt;LOAD_CONST&lt;/code&gt;在0位置。第三列是指令本身对应的人类可读的名字。如果第四列存在，它表示指令的参数。如果第5列存在，它是一个关于参数是什么的提示。&lt;/p&gt;

&lt;p&gt;考虑这个字节码的前几个字节：[100, 1, 0, 125, 0, 0]。这6个字节表示两条带参数的指令。我们可以使用&lt;code&gt;dis.opname&lt;/code&gt;，一个字节到可读字符串的映射，来找到指令100和指令125代表是什么：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; dis.opname[100]
&#39;LOAD_CONST&#39;
&amp;gt;&amp;gt;&amp;gt; dis.opname[125]
&#39;STORE_FAST&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第二和第三个字节 &amp;mdash; 1 ，0 &amp;mdash;是&lt;code&gt;LOAD_CONST&lt;/code&gt;的参数，第五和第六个字节 &amp;mdash; 0，0 &amp;mdash; 是&lt;code&gt;STORE_FAST&lt;/code&gt;的参数。就像我们前面的小例子，&lt;code&gt;LOAD_CONST&lt;/code&gt;需要知道的到哪去找常量，&lt;code&gt;STORE_FAST&lt;/code&gt;需要找到名字。（Python的&lt;code&gt;LOAD_CONST&lt;/code&gt;和我们小例子中的&lt;code&gt;LOAD_VALUE&lt;/code&gt;一样，&lt;code&gt;LOAD_FAST&lt;/code&gt;和&lt;code&gt;LOAD_NAME&lt;/code&gt;一样）。所以这六个字节代表第一行源代码&lt;code&gt;x = 3&lt;/code&gt;.(为什么用两个字节表示指令的参数？如果Python使用一个字节，每个code object你只能有256个常量/名字，而用两个字节，就增加到了256的平方，65536个）。&lt;/p&gt;

&lt;h3 id=&#34;conditionals-and-loops&#34;&gt;Conditionals and Loops&lt;/h3&gt;

&lt;p&gt;到目前为止，我们的解释器只能一条接着一条的执行指令。这有个问题，我们经常会想多次执行某个指令，或者在特定的条件下跳过它们。为了可以写循环和分支结构，解释器必须能够在指令中跳转。在某种程度上，Python在字节码中使用&lt;code&gt;GOTO&lt;/code&gt;语句来处理循环和分支！让我们再看一个&lt;code&gt;cond&lt;/code&gt;函数的反汇编结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; dis.dis(cond)
  2           0 LOAD_CONST               1 (3)
              3 STORE_FAST               0 (x)

  3           6 LOAD_FAST                0 (x)
              9 LOAD_CONST               2 (5)
             12 COMPARE_OP               0 (&amp;lt;)
             15 POP_JUMP_IF_FALSE       22

  4          18 LOAD_CONST               3 (&#39;yes&#39;)
             21 RETURN_VALUE

  6     &amp;gt;&amp;gt;   22 LOAD_CONST               4 (&#39;no&#39;)
             25 RETURN_VALUE
             26 LOAD_CONST               0 (None)
             29 RETURN_VALUE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第三行的条件表达式&lt;code&gt;if x &amp;lt; 5&lt;/code&gt;被编译成四条指令：&lt;code&gt;LOAD_FAST&lt;/code&gt;, &lt;code&gt;LOAD_CONST&lt;/code&gt;, &lt;code&gt;COMPARE_OP&lt;/code&gt;和 &lt;code&gt;POP_JUMP_IF_FALSE&lt;/code&gt;。&lt;code&gt;x &amp;lt; 5&lt;/code&gt;对应加载&lt;code&gt;x&lt;/code&gt;，加载5，比较这两个值。指令&lt;code&gt;POP_JUMP_IF_FALSE&lt;/code&gt;完成&lt;code&gt;if&lt;/code&gt;语句。这条指令把栈顶的值弹出，如果值为真，什么都不发生。如果值为假，解释器会跳转到另一条指令。&lt;/p&gt;

&lt;p&gt;这条将被加载的指令称为跳转目标，它作为指令&lt;code&gt;POP_JUMP&lt;/code&gt;的参数。这里，跳转目标是22，索引为22的指令是&lt;code&gt;LOAD_CONST&lt;/code&gt;,对应源码的第6行。（&lt;code&gt;dis&lt;/code&gt;用&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;标记跳转目标。）如果&lt;code&gt;X &amp;lt; 5&lt;/code&gt;为假，解释器会忽略第四行（&lt;code&gt;return yes&lt;/code&gt;）,直接跳转到第6行（&lt;code&gt;return &amp;quot;no&amp;quot;&lt;/code&gt;）。因此解释器通过跳转指令选择性的执行指令。&lt;/p&gt;

&lt;p&gt;Python的循环也依赖于跳转。在下面的字节码中，&lt;code&gt;while x &amp;lt; 5&lt;/code&gt;这一行产生了和&lt;code&gt;if x &amp;lt; 10&lt;/code&gt;几乎一样的字节码。在这两种情况下，解释器都是先执行比较，然后执行&lt;code&gt;POP_JUMP_IF_FALSE&lt;/code&gt;来控制下一条执行哪个指令。第四行的最后一条字节码&lt;code&gt;JUMP_ABSOLUT&lt;/code&gt;(循环体结束的地方），让解释器返回到循环开始的第9条指令处。当 &lt;code&gt;x &amp;lt; 10&lt;/code&gt;变为假，&lt;code&gt;POP_JUMP_IF_FALSE&lt;/code&gt;会让解释器跳到循环的终止处，第34条指令。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; def loop():
...      x = 1
...      while x &amp;lt; 5:
...          x = x + 1
...      return x
...
&amp;gt;&amp;gt;&amp;gt; dis.dis(loop)
  2           0 LOAD_CONST               1 (1)
              3 STORE_FAST               0 (x)

  3           6 SETUP_LOOP              26 (to 35)
        &amp;gt;&amp;gt;    9 LOAD_FAST                0 (x)
             12 LOAD_CONST               2 (5)
             15 COMPARE_OP               0 (&amp;lt;)
             18 POP_JUMP_IF_FALSE       34

  4          21 LOAD_FAST                0 (x)
             24 LOAD_CONST               1 (1)
             27 BINARY_ADD
             28 STORE_FAST               0 (x)
             31 JUMP_ABSOLUTE            9
        &amp;gt;&amp;gt;   34 POP_BLOCK

  5     &amp;gt;&amp;gt;   35 LOAD_FAST                0 (x)
             38 RETURN_VALUE
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;explore-bytecode&#34;&gt;Explore Bytecode&lt;/h3&gt;

&lt;p&gt;我希望你用&lt;code&gt;dis.dis&lt;/code&gt;来试试你自己写的函数。一些有趣的问题值得探索：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;对解释器而言for循环和while循环有什么不同？&lt;/li&gt;
&lt;li&gt;能不能写出两个不同函数，却能产生相同的字节码?&lt;/li&gt;
&lt;li&gt;&lt;code&gt;elif&lt;/code&gt;是怎么工作的？列表推导呢？&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;frames&#34;&gt;Frames&lt;/h2&gt;

&lt;p&gt;到目前为止，我们已经知道了Python虚拟机是一个栈机器。它能顺序执行指令，在指令间跳转，压入或弹出栈值。但是这和我们期望的解释器还有一定距离。在前面的那个例子中，最后一条指令是&lt;code&gt;RETURN_VALUE&lt;/code&gt;,它和&lt;code&gt;return&lt;/code&gt;语句相对应。但是它返回到哪里去呢？&lt;/p&gt;

&lt;p&gt;为了回答这个问题，我们必须再增加一层复杂性：frame。一个frame是一些信息的集合和代码的执行上下文。frames在Python代码执行时动态的创建和销毁。每个frame对应函数的一次调用。&amp;mdash; 所以每个frame只有一个code object与之关联，而一个code object可以有多个frame。比如你有一个函数递归的调用自己10次，这会产生11个frame，每次调用对应一个，再加上启动模块对应的一个frame。总的来说，Python程序的每个作用域有一个frame，比如，模块，函数，类。&lt;/p&gt;

&lt;p&gt;Frame存在于_调用栈_中，一个和我们之前讨论的完全不同的栈。（你最熟悉的栈就是调用栈，就是你经常看到的异常回溯，每个以&amp;rdquo;File &amp;lsquo;program.py&amp;rsquo;&amp;ldquo;开始的回溯对应一个frame。）解释器在执行字节码时操作的栈，我们叫它_数据栈_。其实还有第三个栈，叫做_块栈_，用于特定的控制流块，比如循环和异常处理。调用栈中的每个frame都有它自己的数据栈和块栈。&lt;/p&gt;

&lt;p&gt;让我们用一个具体的例子来说明。假设Python解释器执行到标记为3的地方。解释器正在&lt;code&gt;foo&lt;/code&gt;函数的调用中，它接着调用&lt;code&gt;bar&lt;/code&gt;。下面是frame调用栈，块栈和数据栈的示意图。我们感兴趣的是解释器先从最底下的&lt;code&gt;foo()&lt;/code&gt;开始，接着执行&lt;code&gt;foo&lt;/code&gt;的函数体，然后到达&lt;code&gt;bar&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; def bar(y):
...     z = y + 3     # &amp;lt;--- (3) ... and the interpreter is here.
...     return z
...
&amp;gt;&amp;gt;&amp;gt; def foo():
...     a = 1
...     b = 2
...     return a + bar(b) # &amp;lt;--- (2) ... which is returning a call to bar ...
...
&amp;gt;&amp;gt;&amp;gt; foo()             # &amp;lt;--- (1) We&#39;re in the middle of a call to foo ...
3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;\aosafigure[240pt]{interpreter-images/interpreter-callstack.png}{The call stack}{500l.interpreter.callstack}&lt;/p&gt;

&lt;p&gt;现在，解释器在&lt;code&gt;bar&lt;/code&gt;函数的调用中。调用栈中有3个frame：一个对应于模块层，一个对应函数&lt;code&gt;foo&lt;/code&gt;,别一个对应函数&lt;code&gt;bar&lt;/code&gt;。(\aosafigref{500l.interpreter.callstack}.)一旦&lt;code&gt;bar&lt;/code&gt;返回，与它对应的frame就会从调用栈中弹出并丢弃。&lt;/p&gt;

&lt;p&gt;字节码指令&lt;code&gt;RETURN_VALUE&lt;/code&gt;告诉解释器在frame间传递一个值。首先，它把位于调用栈栈顶的frame中的数据栈的栈顶值弹出。然后把整个frame弹出丢弃。最后把这个值压到下一个frame的数据栈中。&lt;/p&gt;

&lt;p&gt;当Ned Batchelder和我在写Byterun时，很长一段时间我们的实现中一直有个重大的错误。我们整个虚拟机中只有一个数据栈，而不是每个frame都有一个。我们写了很多测试代码，同时在Byterun和真正的Python上运行，希望得到一致结果。我们几乎通过了所有测试，只有一样东西不能通过，那就是生成器。最后，通过仔细的阅读CPython的源码，我们发现了错误所在&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:thanks&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:thanks&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。把数据栈移到每个frame就解决了这个问题。&lt;/p&gt;

&lt;p&gt;回头在看看这个bug，我惊讶的发现Python真的很少依赖于每个frame有一个数据栈这个特性。在Python中几乎所有的操作都会清空数据栈，所以所有的frame公用一个数据栈是没问题的。在上面的例子中，当&lt;code&gt;bar&lt;/code&gt;执行完后，它的数据栈为空。即使&lt;code&gt;foo&lt;/code&gt;公用这一个栈，它的值也不会受影响。然而，对应生成器，一个关键的特点是它能暂停一个frame的执行，返回到其他的frame，一段时间后它能返回到原来的frame，并以它离开时的相同状态继续执行。&lt;/p&gt;

&lt;h2 id=&#34;byterun&#34;&gt;Byterun&lt;/h2&gt;

&lt;p&gt;现在我们有足够的Python解释器的知识背景去考察Byterun。&lt;/p&gt;

&lt;p&gt;Byterun中有四种对象。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;VirtualMachine&lt;/code&gt;类，它管理高层结构，frame调用栈，指令到操作的映射。这是一个比前面&lt;code&gt;Inteprter&lt;/code&gt;对象更复杂的版本。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Frame&lt;/code&gt;类，每个&lt;code&gt;Frame&lt;/code&gt;类都有一个code object，并且管理者其他一些必要的状态信息，全局和局部命名空间，指向调用它的frame的指针和最后执行的字节码指令。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Function&lt;/code&gt;类，它被用来代替真正的Python函数。回想一下，调用函数时会创建一个新的frame。我们自己实现&lt;code&gt;Function&lt;/code&gt;，所以我们控制新frame的创建。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Block&lt;/code&gt;类，它只是包装了block的3个属性。（block的细节不是解释器的核心，我们不会花时间在它身上，把它列在这里，是因为Byterun需要它。）&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;the-virtualmachine-class&#34;&gt;The &lt;code&gt;VirtualMachine&lt;/code&gt; Class&lt;/h3&gt;

&lt;p&gt;程序运行时只有一个&lt;code&gt;VirtualMachine&lt;/code&gt;被创建，因为我们只有一个解释器。&lt;code&gt;VirtualMachine&lt;/code&gt;保存调用栈，异常状态，在frame中传递的返回值。它的入口点是&lt;code&gt;run_code&lt;/code&gt;方法，它以编译后的code object为参数，以创建一个frame为开始，然后运行这个frame。这个frame可能再创建出新的frame；调用栈随着程序的运行增长缩短。当第一个frame返回时，执行结束。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class VirtualMachineError(Exception):
    pass

class VirtualMachine(object):
    def __init__(self):
        self.frames = []   # The call stack of frames.
        self.frame = None  # The current frame.
        self.return_value = None
        self.last_exception = None

    def run_code(self, code, global_names=None, local_names=None):
        &amp;quot;&amp;quot;&amp;quot; An entry point to execute code using the virtual machine.&amp;quot;&amp;quot;&amp;quot;
        frame = self.make_frame(code, global_names=global_names, 
                                local_names=local_names)
        self.run_frame(frame)

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;the-frame-class&#34;&gt;The &lt;code&gt;Frame&lt;/code&gt; Class&lt;/h3&gt;

&lt;p&gt;接下来，我们来写&lt;code&gt;Frame&lt;/code&gt;对象。frame是一个属性的集合，它没有任何方法。前面提到过，这些属性包括由编译器生成的code object；局部，全局和内置命名空间；前一个frame的引用；一个数据栈；一个块栈；最后执行的指令指针。（对于内置命名空间我们需要多做一点工作，Python在不同模块中对这个命名空间有不同的处理；但这个细节对我们的虚拟机不重要。）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Frame(object):
    def __init__(self, code_obj, global_names, local_names, prev_frame):
        self.code_obj = code_obj
        self.global_names = global_names
        self.local_names = local_names
        self.prev_frame = prev_frame
        self.stack = []
        if prev_frame:
            self.builtin_names = prev_frame.builtin_names
        else:
            self.builtin_names = local_names[&#39;__builtins__&#39;]
            if hasattr(self.builtin_names, &#39;__dict__&#39;):
                self.builtin_names = self.builtin_names.__dict__

        self.last_instruction = 0
        self.block_stack = []
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着，我们在虚拟机中增加对frame的操作。这有3个帮助函数：一个创建新的frame的方法，和压栈和出栈的方法。第四个函数，&lt;code&gt;run_frame&lt;/code&gt;,完成执行frame的主要工作，待会我们再讨论这个方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class VirtualMachine(object):
    [... snip ...]

    # Frame manipulation
    def make_frame(self, code, callargs={}, global_names=None, local_names=None):
        if global_names is not None and local_names is not None:
            local_names = global_names
        elif self.frames:
            global_names = self.frame.global_names
            local_names = {}
        else:
            global_names = local_names = {
                &#39;__builtins__&#39;: __builtins__,
                &#39;__name__&#39;: &#39;__main__&#39;,
                &#39;__doc__&#39;: None,
                &#39;__package__&#39;: None,
            }
        local_names.update(callargs)
        frame = Frame(code, global_names, local_names, self.frame)
        return frame

    def push_frame(self, frame):
        self.frames.append(frame)
        self.frame = frame

    def pop_frame(self):
        self.frames.pop()
        if self.frames:
            self.frame = self.frames[-1]
        else:
            self.frame = None

    def run_frame(self):
        pass
        # we&#39;ll come back to this shortly
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;the-function-class&#34;&gt;The &lt;code&gt;Function&lt;/code&gt; Class&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Function&lt;/code&gt;的实现有点扭曲，但是大部分的细节对理解解释器不重要。重要的是当调用函数时 &amp;mdash; &lt;code&gt;__call__&lt;/code&gt;方法被调用 &amp;mdash; 它创建一个新的&lt;code&gt;Frame&lt;/code&gt;并运行它。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Function(object):
    &amp;quot;&amp;quot;&amp;quot;
    Create a realistic function object, defining the things the interpreter expects.
    &amp;quot;&amp;quot;&amp;quot;
    __slots__ = [
        &#39;func_code&#39;, &#39;func_name&#39;, &#39;func_defaults&#39;, &#39;func_globals&#39;,
        &#39;func_locals&#39;, &#39;func_dict&#39;, &#39;func_closure&#39;,
        &#39;__name__&#39;, &#39;__dict__&#39;, &#39;__doc__&#39;,
        &#39;_vm&#39;, &#39;_func&#39;,
    ]

    def __init__(self, name, code, globs, defaults, closure, vm):
        &amp;quot;&amp;quot;&amp;quot;You don&#39;t need to follow this closely to understand the interpreter.&amp;quot;&amp;quot;&amp;quot;
        self._vm = vm
        self.func_code = code
        self.func_name = self.__name__ = name or code.co_name
        self.func_defaults = tuple(defaults)
        self.func_globals = globs
        self.func_locals = self._vm.frame.f_locals
        self.__dict__ = {}
        self.func_closure = closure
        self.__doc__ = code.co_consts[0] if code.co_consts else None

        # Sometimes, we need a real Python function.  This is for that.
        kw = {
            &#39;argdefs&#39;: self.func_defaults,
        }
        if closure:
            kw[&#39;closure&#39;] = tuple(make_cell(0) for _ in closure)
        self._func = types.FunctionType(code, globs, **kw)

    def __call__(self, *args, **kwargs):
        &amp;quot;&amp;quot;&amp;quot;When calling a Function, make a new frame and run it.&amp;quot;&amp;quot;&amp;quot;
        callargs = inspect.getcallargs(self._func, *args, **kwargs)
        # Use callargs to provide a mapping of arguments: values to pass into the new 
        # frame.
        frame = self._vm.make_frame(
            self.func_code, callargs, self.func_globals, {}
        )
        return self._vm.run_frame(frame)

def make_cell(value):
    &amp;quot;&amp;quot;&amp;quot;Create a real Python closure and grab a cell.&amp;quot;&amp;quot;&amp;quot;
    # Thanks to Alex Gaynor for help with this bit of twistiness.
    fn = (lambda x: lambda: x)(value)
    return fn.__closure__[0]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着，回到&lt;code&gt;VirtualMachine&lt;/code&gt;对象，我们对数据栈的操作也增加一些帮助方法。字节码操作的栈总是在当前frame的数据栈。这些帮助函数让我们能实现&lt;code&gt;POP_TOP&lt;/code&gt;,&lt;code&gt;LOAD_FAST&lt;/code&gt;字节码,并且让其他操作栈的指令可读性更高。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class VirtualMachine(object):
    [... snip ...]

    # Data stack manipulation
    def top(self):
        return self.frame.stack[-1]

    def pop(self):
        return self.frame.stack.pop()

    def push(self, *vals):
        self.frame.stack.extend(vals)

    def popn(self, n):
        &amp;quot;&amp;quot;&amp;quot;Pop a number of values from the value stack.
        A list of `n` values is returned, the deepest value first.
        &amp;quot;&amp;quot;&amp;quot;
        if n:
            ret = self.frame.stack[-n:]
            self.frame.stack[-n:] = []
            return ret
        else:
            return []
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在我们运行frame之前，我们还需两个方法。&lt;/p&gt;

&lt;p&gt;第一个方法，&lt;code&gt;parse_byte_and_args&lt;/code&gt;,以一个字节码为输入，先检查它是否有参数，如果有，就解析它的参数。这个方法同时也更新frame的&lt;code&gt;last_instruction&lt;/code&gt;属性，它指向最后执行的指令。一条没有参数的指令只有一个字节长度，而有参数的字节有3个字节长。参数的意义依赖于指令是什么。比如，前面说过，指令&lt;code&gt;POP_JUMP_IF_FALSE&lt;/code&gt;,它的参数指的是跳转目标。&lt;code&gt;BUILD_LIST&lt;/code&gt;, 它的参数是列表的个数。&lt;code&gt;LOAD_CONST&lt;/code&gt;,它的参数是常量的索引。&lt;/p&gt;

&lt;p&gt;一些指令用简单的数字作为参数。对于另一些，虚拟机需要一点努力去发现它含意。标准库中的&lt;code&gt;dis&lt;/code&gt;模块中有一个备忘单，它解释什么参数有什么意思，这让我们的代码更加简洁。比如，列表&lt;code&gt;dis.hasname&lt;/code&gt;告诉我们&lt;code&gt;LOAD_NAME&lt;/code&gt;, &lt;code&gt;IMPORT_NAME&lt;/code&gt;,&lt;code&gt;LOAD_GLOBAL&lt;/code&gt;,以及另外的9个指令都有同样的意思：名字列表的索引。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class VirtualMachine(object):
    [... snip ...]

    def parse_byte_and_args(self):
        f = self.frame
        opoffset = f.last_instruction
        byteCode = f.code_obj.co_code[opoffset]
        f.last_instruction += 1
        byte_name = dis.opname[byteCode]
        if byteCode &amp;gt;= dis.HAVE_ARGUMENT:
            # index into the bytecode
            arg = f.code_obj.co_code[f.last_instruction:f.last_instruction+2]  
            f.last_instruction += 2   # advance the instruction pointer
            arg_val = arg[0] + (arg[1] * 256)
            if byteCode in dis.hasconst:   # Look up a constant
                arg = f.code_obj.co_consts[arg_val]
            elif byteCode in dis.hasname:  # Look up a name
                arg = f.code_obj.co_names[arg_val]
            elif byteCode in dis.haslocal: # Look up a local name
                arg = f.code_obj.co_varnames[arg_val]
            elif byteCode in dis.hasjrel:  # Calculate a relative jump
                arg = f.last_instruction + arg_val
            else:
                arg = arg_val
            argument = [arg]
        else:
            argument = []

        return byte_name, argument
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下一个方法是&lt;code&gt;dispatch&lt;/code&gt;,它查看给定的指令并执行相应的操作。在CPython中，这个分派函数用一个巨大的switch语句实现，有超过1500行的代码。幸运的是，我们用的是Python，我们的代码会简洁的多。我们会为每一个字节码名字定义一个方法，然后用&lt;code&gt;getattr&lt;/code&gt;来查找。就像我们前面的小解释器一样，如果一条指令叫做&lt;code&gt;FOO_BAR&lt;/code&gt;，那么它对应的方法就是&lt;code&gt;byte_FOO_BAR&lt;/code&gt;。现在，我们先把这些方法当做一个黑盒子。每个指令方法都会返回&lt;code&gt;None&lt;/code&gt;或者一个字符串&lt;code&gt;why&lt;/code&gt;,有些情况下虚拟机需要这个额外&lt;code&gt;why&lt;/code&gt;信息。这些指令方法的返回值，仅作为解释器状态的内部指示，千万不要和执行frame的返回值相混淆。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class VirtualMachine(object):
    [... snip ...]

    def dispatch(self, byte_name, argument):
        &amp;quot;&amp;quot;&amp;quot; Dispatch by bytename to the corresponding methods.
        Exceptions are caught and set on the virtual machine.&amp;quot;&amp;quot;&amp;quot;

        # When later unwinding the block stack,
        # we need to keep track of why we are doing it.
        why = None
        try:
            bytecode_fn = getattr(self, &#39;byte_%s&#39; % byte_name, None)
            if bytecode_fn is None:
                if byte_name.startswith(&#39;UNARY_&#39;):
                    self.unaryOperator(byte_name[6:])
                elif byte_name.startswith(&#39;BINARY_&#39;):
                    self.binaryOperator(byte_name[7:])
                else:
                    raise VirtualMachineError(
                        &amp;quot;unsupported bytecode type: %s&amp;quot; % byte_name
                    )
            else:
                why = bytecode_fn(*argument)
        except:
            # deal with exceptions encountered while executing the op.
            self.last_exception = sys.exc_info()[:2] + (None,)
            why = &#39;exception&#39;

        return why

    def run_frame(self, frame):
        &amp;quot;&amp;quot;&amp;quot;Run a frame until it returns (somehow).
        Exceptions are raised, the return value is returned.
        &amp;quot;&amp;quot;&amp;quot;
        self.push_frame(frame)
        while True:
            byte_name, arguments = self.parse_byte_and_args()

            why = self.dispatch(byte_name, arguments)

            # Deal with any block management we need to do
            while why and frame.block_stack:
                why = self.manage_block_stack(why)

            if why:
                break

        self.pop_frame()

        if why == &#39;exception&#39;:
            exc, val, tb = self.last_exception
            e = exc(val)
            e.__traceback__ = tb
            raise e

        return self.return_value
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;the-block-class&#34;&gt;The &lt;code&gt;Block&lt;/code&gt; Class&lt;/h3&gt;

&lt;p&gt;在我们完成每个字节码方法前，我们简单的讨论一下块。一个块被用于某种控制流，特别是异常处理和循环。它负责保证当操作完成后数据栈处于正确的状态。比如，在一个循环中，一个特殊的迭代器会存在栈中，当循环完成时它从栈中弹出。解释器需要检查循环仍在继续还是已经停止。&lt;/p&gt;

&lt;p&gt;为了跟踪这些额外的信息，解释器设置了一个标志来指示它的状态。我们用一个变量&lt;code&gt;why&lt;/code&gt;实现这个标志，它可以是&lt;code&gt;None&lt;/code&gt;或者是下面几个字符串这一，&lt;code&gt;&amp;quot;continue&amp;quot;&lt;/code&gt;, &lt;code&gt;&amp;quot;break&amp;quot;&lt;/code&gt;,&lt;code&gt;&amp;quot;excption&amp;quot;&lt;/code&gt;,&lt;code&gt;return&lt;/code&gt;。他们指示对块栈和数据栈进行什么操作。回到我们迭代器的例子，如果块栈的栈顶是一个&lt;code&gt;loop&lt;/code&gt;块，&lt;code&gt;why&lt;/code&gt;是&lt;code&gt;continue&lt;/code&gt;,迭代器就因该保存在数据栈上，不是如果&lt;code&gt;why&lt;/code&gt;是&lt;code&gt;break&lt;/code&gt;,迭代器就会被弹出。&lt;/p&gt;

&lt;p&gt;块操作的细节比较精细，我们不会花时间在这上面，但是有兴趣的读者值得仔细的看看。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;Block = collections.namedtuple(&amp;quot;Block&amp;quot;, &amp;quot;type, handler, stack_height&amp;quot;)

class VirtualMachine(object):
    [... snip ...]

    # Block stack manipulation
    def push_block(self, b_type, handler=None):
        level = len(self.frame.stack)
        self.frame.block_stack.append(Block(b_type, handler, stack_height))

    def pop_block(self):
        return self.frame.block_stack.pop()

    def unwind_block(self, block):
        &amp;quot;&amp;quot;&amp;quot;Unwind the values on the data stack corresponding to a given block.&amp;quot;&amp;quot;&amp;quot;
        if block.type == &#39;except-handler&#39;:
            # The exception itself is on the stack as type, value, and traceback.
            offset = 3  
        else:
            offset = 0

        while len(self.frame.stack) &amp;gt; block.level + offset:
            self.pop()

        if block.type == &#39;except-handler&#39;:
            traceback, value, exctype = self.popn(3)
            self.last_exception = exctype, value, traceback

    def manage_block_stack(self, why):
        &amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot;
        frame = self.frame
        block = frame.block_stack[-1]
        if block.type == &#39;loop&#39; and why == &#39;continue&#39;:
            self.jump(self.return_value)
            why = None
            return why

        self.pop_block()
        self.unwind_block(block)

        if block.type == &#39;loop&#39; and why == &#39;break&#39;:
            why = None
            self.jump(block.handler)
            return why

        if (block.type in [&#39;setup-except&#39;, &#39;finally&#39;] and why == &#39;exception&#39;):
            self.push_block(&#39;except-handler&#39;)
            exctype, value, tb = self.last_exception
            self.push(tb, value, exctype)
            self.push(tb, value, exctype) # yes, twice
            why = None
            self.jump(block.handler)
            return why

        elif block.type == &#39;finally&#39;:
            if why in (&#39;return&#39;, &#39;continue&#39;):
                self.push(self.return_value)

            self.push(why)

            why = None
            self.jump(block.handler)
            return why
        return why
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;the-instructions&#34;&gt;The Instructions&lt;/h2&gt;

&lt;p&gt;剩下了的就是完成那些指令方法了：&lt;code&gt;byte_LOAD_FAST&lt;/code&gt;,&lt;code&gt;byte_BINARY_MODULO&lt;/code&gt;等等。而这些指令的实现并不是很有趣，这里我们只展示了一小部分，完整的实现在这儿&lt;a href=&#34;https://github.com/nedbat/byterun。（足够执行我们前面所述的所有代码了。）&#34;&gt;https://github.com/nedbat/byterun。（足够执行我们前面所述的所有代码了。）&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class VirtualMachine(object):
    [... snip ...]

    ## Stack manipulation

    def byte_LOAD_CONST(self, const):
        self.push(const)

    def byte_POP_TOP(self):
        self.pop()

    ## Names
    def byte_LOAD_NAME(self, name):
        frame = self.frame
        if name in frame.f_locals:
            val = frame.f_locals[name]
        elif name in frame.f_globals:
            val = frame.f_globals[name]
        elif name in frame.f_builtins:
            val = frame.f_builtins[name]
        else:
            raise NameError(&amp;quot;name &#39;%s&#39; is not defined&amp;quot; % name)
        self.push(val)

    def byte_STORE_NAME(self, name):
        self.frame.f_locals[name] = self.pop()

    def byte_LOAD_FAST(self, name):
        if name in self.frame.f_locals:
            val = self.frame.f_locals[name]
        else:
            raise UnboundLocalError(
                &amp;quot;local variable &#39;%s&#39; referenced before assignment&amp;quot; % name
            )
        self.push(val)

    def byte_STORE_FAST(self, name):
        self.frame.f_locals[name] = self.pop()

    def byte_LOAD_GLOBAL(self, name):
        f = self.frame
        if name in f.f_globals:
            val = f.f_globals[name]
        elif name in f.f_builtins:
            val = f.f_builtins[name]
        else:
            raise NameError(&amp;quot;global name &#39;%s&#39; is not defined&amp;quot; % name)
        self.push(val)

    ## Operators

    BINARY_OPERATORS = {
        &#39;POWER&#39;:    pow,
        &#39;MULTIPLY&#39;: operator.mul,
        &#39;FLOOR_DIVIDE&#39;: operator.floordiv,
        &#39;TRUE_DIVIDE&#39;:  operator.truediv,
        &#39;MODULO&#39;:   operator.mod,
        &#39;ADD&#39;:      operator.add,
        &#39;SUBTRACT&#39;: operator.sub,
        &#39;SUBSCR&#39;:   operator.getitem,
        &#39;LSHIFT&#39;:   operator.lshift,
        &#39;RSHIFT&#39;:   operator.rshift,
        &#39;AND&#39;:      operator.and_,
        &#39;XOR&#39;:      operator.xor,
        &#39;OR&#39;:       operator.or_,
    }

    def binaryOperator(self, op):
        x, y = self.popn(2)
        self.push(self.BINARY_OPERATORS[op](x, y))

    COMPARE_OPERATORS = [
        operator.lt,
        operator.le,
        operator.eq,
        operator.ne,
        operator.gt,
        operator.ge,
        lambda x, y: x in y,
        lambda x, y: x not in y,
        lambda x, y: x is y,
        lambda x, y: x is not y,
        lambda x, y: issubclass(x, Exception) and issubclass(x, y),
    ]

    def byte_COMPARE_OP(self, opnum):
        x, y = self.popn(2)
        self.push(self.COMPARE_OPERATORS[opnum](x, y))

    ## Attributes and indexing

    def byte_LOAD_ATTR(self, attr):
        obj = self.pop()
        val = getattr(obj, attr)
        self.push(val)

    def byte_STORE_ATTR(self, name):
        val, obj = self.popn(2)
        setattr(obj, name, val)

    ## Building

    def byte_BUILD_LIST(self, count):
        elts = self.popn(count)
        self.push(elts)

    def byte_BUILD_MAP(self, size):
        self.push({})

    def byte_STORE_MAP(self):
        the_map, val, key = self.popn(3)
        the_map[key] = val
        self.push(the_map)

    def byte_LIST_APPEND(self, count):
        val = self.pop()
        the_list = self.frame.stack[-count] # peek
        the_list.append(val)

    ## Jumps

    def byte_JUMP_FORWARD(self, jump):
        self.jump(jump)

    def byte_JUMP_ABSOLUTE(self, jump):
        self.jump(jump)

    def byte_POP_JUMP_IF_TRUE(self, jump):
        val = self.pop()
        if val:
            self.jump(jump)

    def byte_POP_JUMP_IF_FALSE(self, jump):
        val = self.pop()
        if not val:
            self.jump(jump)

    ## Blocks

    def byte_SETUP_LOOP(self, dest):
        self.push_block(&#39;loop&#39;, dest)

    def byte_GET_ITER(self):
        self.push(iter(self.pop()))

    def byte_FOR_ITER(self, jump):
        iterobj = self.top()
        try:
            v = next(iterobj)
            self.push(v)
        except StopIteration:
            self.pop()
            self.jump(jump)

    def byte_BREAK_LOOP(self):
        return &#39;break&#39;

    def byte_POP_BLOCK(self):
        self.pop_block()

    ## Functions

    def byte_MAKE_FUNCTION(self, argc):
        name = self.pop()
        code = self.pop()
        defaults = self.popn(argc)
        globs = self.frame.f_globals
        fn = Function(name, code, globs, defaults, None, self)
        self.push(fn)

    def byte_CALL_FUNCTION(self, arg):
        lenKw, lenPos = divmod(arg, 256) # KWargs not supported here
        posargs = self.popn(lenPos)

        func = self.pop()
        frame = self.frame
        retval = func(*posargs)
        self.push(retval)

    def byte_RETURN_VALUE(self):
        self.return_value = self.pop()
        return &amp;quot;return&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;dynamic-typing-what-the-compiler-doesn-t-know&#34;&gt;Dynamic Typing: What the Compiler Doesn&amp;rsquo;t Know&lt;/h2&gt;

&lt;p&gt;你可能听过Python是一种动态语言 &amp;mdash; 是它是动态类型的。在我们建造解释器的过程中，已经透露出这样的信息。&lt;/p&gt;

&lt;p&gt;动态的一个意思是很多工作在运行时完成。前面我们看到Python的编译器没有很多关于代码真正做什么的信息。举个例子，考虑下面这个简单的函数&lt;code&gt;mod&lt;/code&gt;。它取两个参数，返回它们的模运算值。从它的字节码中，我们看到变量&lt;code&gt;a&lt;/code&gt;和&lt;code&gt;b&lt;/code&gt;首先被加载，然后字节码&lt;code&gt;BINAY_MODULO&lt;/code&gt;完成这个模运算。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; def mod(a, b):
...    return a % b
&amp;gt;&amp;gt;&amp;gt; dis.dis(mod)
  2           0 LOAD_FAST                0 (a)
              3 LOAD_FAST                1 (b)
              6 BINARY_MODULO
              7 RETURN_VALUE
&amp;gt;&amp;gt;&amp;gt; mod(19, 5)
4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;计算19 % 5得4，&amp;mdash; 一点也不奇怪。如果我们用不同类的参数呢？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; mod(&amp;quot;by%sde&amp;quot;, &amp;quot;teco&amp;quot;)
&#39;bytecode&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;刚才发生了什么？你可能见过这样的语法，格式化字符串。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; print(&amp;quot;by%sde&amp;quot; % &amp;quot;teco&amp;quot;)
bytecode
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用符号&lt;code&gt;%&lt;/code&gt;去格式化字符串会调用字节码&lt;code&gt;BUNARY_MODULO&lt;/code&gt;.它取栈顶的两个值求模，不管这两个值是字符串，数字或是你自己定义的类的实例。字节码在函数编译时生成（或者说，函数定义时）相同的字节码会用于不同类的参数。&lt;/p&gt;

&lt;p&gt;Python的编译器关于字节码的功能知道的很少。而取决于解释器来决定&lt;code&gt;BINAYR_MODULO&lt;/code&gt;应用于什么类型的对象并完成正确的操作。这就是为什么Python被描述为_动态类型_：直到运行前你不必知道这个函数参数的类型。相反，在一个静态类型语言中，程序员需要告诉编译器参数的类型是什么（或者编译器自己推断出参数的类型。）&lt;/p&gt;

&lt;p&gt;编译器的无知是优化Python的一个挑战 &amp;mdash; 只看字节码，而不真正运行它，你就不知道每条字节码在干什么！你可以定义一个类，实现&lt;code&gt;__mod__&lt;/code&gt;方法，当你对这个类的实例使用&lt;code&gt;%&lt;/code&gt;时，Python就会自动调用这个方法。所以，&lt;code&gt;BINARY_MODULO&lt;/code&gt;其实可以运行任何代码。&lt;/p&gt;

&lt;p&gt;看看下面的代码，第一个&lt;code&gt;a % b&lt;/code&gt;看起来没有用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def mod(a,b):
    a % b
    return a %b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不幸的是，对这段代码进行静态分析 &amp;mdash; 不运行它 &amp;mdash; 不能确定第一个&lt;code&gt;a % b&lt;/code&gt;没有做任何事。用 &lt;code&gt;%&lt;/code&gt;调用&lt;code&gt;__mod__&lt;/code&gt;可能会写一个文件，或是和程序的其他部分交互，或者其他任何可以在Python中完成的事。很难优化一个你不知道它会做什么的函数。在Russell Power和Alex Rubinsteyn的优秀论文中写道，“我们可以用多快的速度解释Python？”，他们说，“在普遍缺乏类型信息下，每条指令必须被看作一个&lt;code&gt;INVOKE_ARBITRARY_METHOD&lt;/code&gt;。”&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Byterun是一个比CPython容易理解的简洁的Python解释器。Byterun复制了CPython的主要结构：一个基于栈的指令集称为字节码，它们顺序执行或在指令间跳转，向栈中压入和从中弹出数据。解释器随着函数和生成器的调用和返回，动态的创建，销毁frame，并在frame间跳转。Byterun也有着和真正解释器一样的限制：因为Python使用动态类型，解释器必须在运行时决定指令的正确行为。&lt;/p&gt;

&lt;p&gt;我鼓励你去反汇编你的程序，然后用Byterun来运行。你很快会发现这个缩短版的Byterun所没有实现的指令。完整的实现在&lt;a href=&#34;https://github.com/nedbat/byterun，或者仔细阅读真正的CPython解释器`ceval.c`,你也可以实现自己的解释器！&#34;&gt;https://github.com/nedbat/byterun，或者仔细阅读真正的CPython解释器`ceval.c`,你也可以实现自己的解释器！&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;acknowledgements&#34;&gt;Acknowledgements&lt;/h2&gt;

&lt;p&gt;Thanks to Ned Batchelder for originating this project and guiding my contributions, Michael Arntzenius for his help debugging the code and editing the prose, Leta Montopoli for her edits, and the entire Recurse Center community for their support and interest. Any errors are my own.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:thanks&#34;&gt;感谢 Michael Arntzenius 对这个bug的洞悉。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:thanks&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>