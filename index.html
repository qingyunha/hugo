<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="generator" content="Hugo 0.16" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    <link rel='stylesheet' href='//fonts.googleapis.com/css?family=Noticia+Text:400,700|Marcellus+SC'>
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/solarized_dark.min.css">
    <link rel="stylesheet" href="http://qingyunha.github.io/hugo/css/styles.css">
    <link rel="stylesheet" href="http://qingyunha.github.io/hugo/css/custom.css">
    <link rel="alternate" type="application/rss+xml" title="RSS" href="http://qingyunha.github.io/hugo/index.xml">

    
    <title>Qing Yun</title>
    <meta property='og:title' content="Qing Yun">
    <meta property="og:type" content="website">
    

    <meta property="og:url" content="http://qingyunha.github.io/hugo/">
    
    


</head>

<body>

  <header class="l-header">
    <div class="p-logo">
      <a href="http://qingyunha.github.io/hugo/">Qing Yun</a>
    </div>
  </header>



<div class="container">
  <div class="row">
    <div class="col-md-9">

      <h1 class="p-page-title">Qing Yun</h1>

      <div class="row">
        
        <div class="col-sm-4">
          <article class="grid">
  <a href="http://qingyunha.github.io/hugo/blog/python-name/">
    <div class="image" style="background-image: url(http://qingyunha.github.io/hugo/images/default.jpg);"></div>
    <footer>
      <div class="date">
        <time>Mon, Aug 22, 2016</time>
      </div>
      <h2 class="title">python值传递 or 引用传递</h2>
      <div class="summary">当被问到python是值传递还是引用传递的时候，你要回答都不是。 要理解这个问题，首先要知道Python中变量，赋值是怎么一回事，它和C语言有很大不同。 在C语言中，变量可以想象成一个只能装特定类型值的盒子，int a = 5，把数字5放到a盒子中。int b = a，则把a中的5复制一份放入b盒子中。而在Python中，通常的赋值过程被称作name binding，这还包括类和函数定义，import语句，当然还有函数的形参。Python中一切都是对象，即使是数字5，那么现在a = 5的意思就是为5这个对象绑定了一个名字a。你可以把变量想象成一个标签，它现在贴在5这个对象上。b = a, 就是为5又打了个新标签b。 现在就可以很容易解释下面这两个列子： a = 1 def fun(a): a = 2 fun(a) print(a) # 1 l = [] def fun(l): l.append(1) fun(l) print(l) # [1] 有人把这种现象归因于可变对象和不可变对象的区别，而其实这两者并没有可比性，如果把第二个例子改一下： l = [] def fun(l): l = [1, 2, 3] fun(l) print(l) # [] 列表是可变的啊，为什么最后没有打印[1, 2, 3]？在fun开始执行时形参l和fun外的l（不同的作用域）都贴在[]上，当l = [1, 2, 3]被执行，只是把形参l从[]上撕下贴到了[1, 2, 3]上，而fun外的l却依然贴在[]上。 那么Python的参数传递方式到底该叫什么呢？call-by-object-reference，call-by-assignment？在CPython的实现中，名字也是一个对象，而所有的对象都通过PyObject *来引用，名字和对象的绑定关系就是保存在一个Python的字典结构中。不管是赋值还是参数传递，都只是改变了作用域字典中名字对应的对象的引用。也许call-by-object-reference更好些。 reference how-do-i-pass-a-variable-by-reference Is Python pass-by-reference or pass-by-value?</div>
    </footer>
  </a>
</article>

        </div>
        
        <div class="col-sm-4">
          <article class="grid">
  <a href="http://qingyunha.github.io/hugo/blog/read-memcached-1.2.0/">
    <div class="image" style="background-image: url(http://qingyunha.github.io/hugo/images/default.jpg);"></div>
    <footer>
      <div class="date">
        <time>Thu, Aug 18, 2016</time>
      </div>
      <h2 class="title">memcached-1.2.0 源码解读</h2>
      <div class="summary">关键词 ： libevent，状态机，内存分配，hash表 memcached是一个免费开源的高性能分布式(由客户端提供)对象缓存系统。这篇将对memcached 1.2.0的源码的进行一点解读，这是我能找到的最早的发行版。协议定义在doc/protocol.txt下，代码量在3500行左右： $ wc *.[ch] 186 844 5912 assoc.c 71 328 1963 config.h 70 370 2649 daemon.c 322 1056 8560 items.c 2282 7820 68519 memcached.c 278 1379 9781 memcached.h 356 1392 10717 slabs.c 3565 13189 108101 total 编译需要安装libevent依赖和autotools工具。 libevent libevent提供了一种当文件描述符的事件(读，写)发生时执行回调函数的机制，也支持信号和超时回调。memcached用的是libevent的1.x版本，使用了这样几个API： struct event_base *event_init(void) void event_set(struct event *, int, short, void(*)(int, short, void *), void *) int event_add(struct event *ev, const struct timeval *timeout) int event_del(struct event *)</div>
    </footer>
  </a>
</article>

        </div>
        
        <div class="col-sm-4">
          <article class="grid">
  <a href="http://qingyunha.github.io/hugo/wiki/git-proxy/">
    <div class="image" style="background-image: url(http://qingyunha.github.io/hugo/images/default.jpg);"></div>
    <footer>
      <div class="date">
        <time>Sat, Aug 6, 2016</time>
      </div>
      <h2 class="title">git proxy</h2>
      <div class="summary">Git支持多种传输协议，ssh、git、HTTP(S)，甚至ftp，rsync。 当使用不同传输方式时，设置代理的方式也不同。 SSH 当使用SSH协议时，git实际上直接使用ssh命令，所以我们只要给ssh设置好代理就可以了。在~/.ssh/config中： Host github.com User git ProxyCommand nc -x localhost:1080 %h %p 参见ssh_config(5)manual HTTP(S) git使用libcurl来处理HTTP和HTTPS，可以通过设置git的http.proxy选项： git config --global http.proxy socks5://localhost:1080 也可以直接设置curl支持的环境变量，比如ALL_PROXY=socks5://localhost:1080 参见curl(1)的&ndash;proxy选项和git-config(1)中的http.proxy Git 当使用git传输协议时，你可以设置git的gitproxy选项： git config --global core.gitproxy git-proxy 这里的git-proxy是任何一个可执行文件，同时它要能接受2个参数，host、port（git服务器的地址和端口）。git-proxy完成代理工作。 例如这样一个shell脚本： #!/usr/bin/env bash nc -x localhost:1080 $1 $2 也可以直接设置环境变量GIT_PROXY_COMMAND=git-porxy 参见git_config(1) 如何判断git使用何种协议 根据git服务器的url就可以看出： ssh://[user@]host.xz[:port]/path/to/repo.git/ git://host.xz[:port]/path/to/repo.git/ http[s]://host.xz[:port]/path/to/repo.git/ ftp[s]://host.xz[:port]/path/to/repo.git/ rsync://host.xz/path/to/repo.git/ 对于SSH协议，还有一种类似scp的语法： [user@]host.xz:path/to/repo.git/ 参见git-fetch(1)的GIT URLS nc命令 nc(netcat)可以用 -X 指定代理方式：socks4、 sockes5、 HTTPS CONNECT，默认为socks5。 -x 指定代理地址。 参见nc(1) example golang的go get命令会用到git，你可以这样： env ALL_PROXY=socks5://localhost:1080 GIT_PROXY_COMMAND=git-porxy go get -v ./...</div>
    </footer>
  </a>
</article>

        </div>
        
        <div class="col-sm-4">
          <article class="grid">
  <a href="http://qingyunha.github.io/hugo/blog/python-logging/">
    <div class="image" style="background-image: url(http://qingyunha.github.io/hugo/images/default.jpg);"></div>
    <footer>
      <div class="date">
        <time>Sat, Jul 9, 2016</time>
      </div>
      <h2 class="title">python logging</h2>
      <div class="summary">日志对程序的调试和问题的发现很有帮助。如何设置合适的日志需要需要一些考虑。 以python2.7标准库logging为例。 logging分有多种级别: NOTSET DEBUG INFO WARNING ERROR CRITICAL 一个应用中可以有多个logger对象，比如每个module一个logger。 不同logger对象可以设置不同的级别，只有大于该级别的log事件才会被记录。 log的记录和处理是分开的，你可以把log简单的打印出来，写到文件中，甚至遇到高级别log事件时，直接给你发邮件。这是由logging.Handler对象来处理，你可以为一个logger添加多个handler，同时handler也是分级别的，这样你就可以对不同级别的log做出不同的处理了。 每个Logger都有一个唯一的名字，通常用logging.getLogger(__name__)，这样得到的logger的名字就是当前模块的名字,这样还有一个好处，logger是分层的，比如inputlogger就是input.cvs，input.xlslogger的上层。这与python的模块命名空间一致，以.做分割。 这里的分层还意味着log事件会向上层传递，当然你也可以阻止这个行为，通过设置Logger.propagate为False。 logger，handler，formmater(log的格式)的创建，配置可以直接写在代码中，比如： import logging # create logger logger = logging.getLogger('simple_example') logger.setLevel(logging.DEBUG) # create console handler and set level to debug ch = logging.StreamHandler() ch.setLevel(logging.DEBUG) # create formatter formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s') # add formatter to ch ch.setFormatter(formatter) # add ch to logger logger.addHandler(ch) # 'application' code logger.debug('debug message') logging模块也提供了从配置文件设置的方法，使用函数fileConfig()： import logging import</div>
    </footer>
  </a>
</article>

        </div>
        
        <div class="col-sm-4">
          <article class="grid">
  <a href="http://qingyunha.github.io/hugo/translation/crawler/">
    <div class="image" style="background-image: url(http://qingyunha.github.io/hugo/images/default.jpg);"></div>
    <footer>
      <div class="date">
        <time>Sat, Jul 9, 2016</time>
      </div>
      <h2 class="title">A Web Crawler With asyncio Coroutines</h2>
      <div class="summary">Introduction 经典的计算机科学强调高效的算法，尽可能快地完成计算。但是很多网络程序的时间并不是消耗在计算上，而是在等待许多慢速的连接或者低频事件的发生。这些程序暴露出一个新的挑战：如何高效的等待大量网络事件。一个现代的解决方案是异步I/O。 这一章我们将实现一个简单的网络爬虫。这个爬虫只是一个原型式的异步应用，因为它等待许多响应而只做少量的计算。一次爬的网页越多，它就能越快的完成任务。如果它为每个动态的请求启动一个线程的话，随着并发请求数量的增加，它会在耗尽套接字之前，耗尽内存或者线程相关的资源。使用异步I/O可以避免这个的问题。 我们将分三个阶段展示这个例子。首先，我们会实现一个事件循环并用这个事件循环和回调来勾画出一个网络爬虫。它很有效，但是当把它扩展成更复杂的问题时，就会导致无法管理的混乱代码。然后，由于Python的协程不仅有效而且可扩展，我们将用Python的生成器函数实现一个简单的协程。在最后一个阶段，我们将使用Python标准库&rdquo;asyncio&rdquo;中功能完整的协程和异步队列完成这个网络爬虫。 The Task 网络爬虫寻找并下载一个网站上的所有网页，也许还会把它们存档，为它们建立索引。从根URL开始，它获取每个网页，解析出没有遇到过的链接加到队列中。当网页没有未见到过的链接并且队列为空时，它便停止运行。 我们可以通过同时下载大量的网页来加快这一过程。当爬虫发现新的链接，它使用一个新的套接字并行的处理这个新链接，解析响应，添加新链接到队列。当并发很大时，可能会导致性能下降，所以我们会限制并发的数量，在队列保留那些未处理的链接，直到一些正在执行的任务完成。 The Traditional Approach 怎么使一个爬虫并发？传统的做法是创建一个线程池，每个线程使用一个套接字在一段时间内负责一个网页的下载。比如，下载xkcd.com网站的一个网页： def fetch(url): sock = socket.socket() sock.connect(('xkcd.com', 80)) request = 'GET {} HTTP/1.0\r\nHost: xkcd.com\r\n\r\n'.format(url) sock.send(request.encode('ascii')) response = b'' chunk = sock.recv(4096) while chunk: response += chunk chunk = sock.recv(4096) # Page is now downloaded. links = parse_links(response) q.add(links) 套接字操作默认是阻塞的：当一个线程调用一个类似connect和recv方法时，它会阻塞，直到操作完成.1因此，为了同一时间内下载多个网页，我们需要很多线程。一个复杂的应用会通过线程池保持空闲的线程来分摊创建线程的开销。同样的做法也适用于套接字，使用连接池。 到目前为止，线程是昂贵的，操作系统对一个进程，一个用户，一台机器能使用线程做了不同的硬性限制。在Jesse系统中，一个Python线程需要50K的内存，开启上万个线程会失败。每个线程的开销和系统的限制就是这种方式的瓶颈所在。 在Dan Kegel那一篇很有影响力的文章&rdquo;The C10K problem&rdquo;2中，它提出多线程方式在I/O并发上的局限性。他在开始写道， 是时候网络服务器要同时处理成千上万的客户啦，你不这样认为么？毕竟，现在网络是个很大的地方。 Kegel在1999年创造出&rdquo;C10K&rdquo;术语。一万个连接在今天看来还是可接受的，但是问题依然存在，只不过大小不同。回到那时候，对于C10K问题，每个连接启一个线程是不切实际的。现在这个限制已经成指数级增长。确实，我们的玩具网络爬虫使用线程也可以工作的很好。但是，对于有着千万级连接的大规模应用来说，限制依然存在：会消耗掉所有线程，即使套接字还够用。那么我们该如何解决这个问题？ Async 异步I/O框架在一个线程中完成并发操作。让我们看看这是怎么做到的。 异步框架使用*非阻塞*套接字。异步爬虫中，我们在发起到服务器的连接前把套接字设为非阻塞： sock = socket.socket() sock.setblocking(False) try: sock.connect(('xkcd.com', 80)) except BlockingIOError: pass 对一个非阻塞套接字调用connect方法会立即抛出异常，即使它正常工作。这个异常模拟了底层C语言函数的行为，它把errno设置为EINPROGRESS,告诉你操作已经开始。 现在我们的爬虫需要一种知道连接何时建立的方法，这样它才能发送HTTP请求。我们可以简单地使用循环来重试： request = 'GET {} HTTP/1.0\r\nHost: xkcd.com\r\n\r\n'.format(url) encoded = request.encode('ascii') while True: try: sock.send(encoded) break # Done.</div>
    </footer>
  </a>
</article>

        </div>
        
        <div class="col-sm-4">
          <article class="grid">
  <a href="http://qingyunha.github.io/hugo/wiki/flask-dev/">
    <div class="image" style="background-image: url(http://qingyunha.github.io/hugo/images/default.jpg);"></div>
    <footer>
      <div class="date">
        <time>Sat, May 21, 2016</time>
      </div>
      <h2 class="title">成为Flask贡献者</h2>
      <div class="summary">当你clone下Flask项目之后： 使用virtualenv或者venv创建虚拟环境 pip install -e .用开发者模式安装本地Flask py.test tests运行测试代码 (如果不用上面的方法，py.test很难用起来) 在github fork后git add remote fork https://github.com/&lt;username&gt;/flask.git</div>
    </footer>
  </a>
</article>

        </div>
        
        <div class="col-sm-4">
          <article class="grid">
  <a href="http://qingyunha.github.io/hugo/translation/python-interpreter/">
    <div class="image" style="background-image: url(http://qingyunha.github.io/hugo/images/default.jpg);"></div>
    <footer>
      <div class="date">
        <time>Mon, May 9, 2016</time>
      </div>
      <h2 class="title">A Python Interpreter Written in Python</h2>
      <div class="summary">Allison是Dropbox的工程师，在那里她维护着世界上最大的由Python客户组成的网络。在Dropbox之前，她是Recurse Center的导师, 曾在纽约写作。在北美的PyCon做过关于Python内部机制的演讲，并且她喜欢奇怪的bugs。她的博客地址是akaptur.com. Introduction Byterun是一个用Python实现的Python解释器。随着我在Byterun上的工作，我惊讶并很高兴地的发现，这个Python解释器的基础结构可以满足500行的限制。在这一章我们会搞清楚这个解释器的结构，给你足够的知识探索下去。我们的目标不是向你展示解释器的每个细节&mdash;像编程和计算机科学其他有趣的领域一样，你可能会投入几年的时间去搞清楚这个主题。 Byterun是Ned Batchelder和我完成的，建立在Paul Swartz的工作之上。它的结构和主要的Python实现（CPython）差不多，所以理解Byterun会帮助你理解大多数解释器特别是CPython解释器。（如果你不知道你用的是什么Python，那么很可能它就是CPython）。尽管Byterun很小，但它能执行大多数简单的Python程序。 A Python Interpreter 在开始之前，让我们缩小一下“Pyhton解释器”的意思。在讨论Python的时候，“解释器”这个词可以用在很多不同的地方。有的时候解释器指的是REPL，当你在命令行下敲下python时所得到的交互式环境。有时候人们会相互替代的使用Python解释器和Python来说明执行Python代码的这一过程。在本章，“解释器”有一个更精确的意思：执行Python程序过程中的最后一步。 在解释器接手之前，Python会执行其他3个步骤：词法分析，语法解析和编译。这三步合起来把源代码转换成code object,它包含着解释器可以理解的指令。而解释器的工作就是解释code object中的指令。 你可能很奇怪执行Python代码会有编译这一步。Python通常被称为解释型语言，就像Ruby，Perl一样，它们和编译型语言相对，比如C，Rust。然而，这里的术语并不是它看起来的那样精确。大多数解释型语言包括Python，确实会有编译这一步。而Python被称为解释型的原因是相对于编译型语言，它在编译这一步的工作相对较少（解释器做相对多的工作）。在这章后面你会看到，Python的编译器比C语言编译器需要更少的关于程序行为的信息。 A Python Python Interpreter Byterun是一个用Python写的Python解释器，这点可能让你感到奇怪，但没有比用C语言写C语言编译器更奇怪。（事实上，广泛使用的gcc编译器就是用C语言本身写的）你可以用几乎的任何语言写一个Python解释器。 用Python写Python既有优点又有缺点。最大的缺点就是速度：用Byterun执行代码要比用CPython执行慢的多，CPython解释器是用C语言实现的并做了优化。然而Byterun是为了学习而设计的，所以速度对我们不重要。使用Python最大优点是我们可以*仅仅*实现解释器，而不用担心Python运行时的部分，特别是对象系统。比如当Byterun需要创建一个类时，它就会回退到“真正”的Python。另外一个优势是Byterun很容易理解，部分原因是它是用高级语言写的（Python！）（另外我们不会对解释器做优化 &mdash; 再一次，清晰和简单比速度更重要） Building an Interpreter 在我们考察Byterun代码之前，我们需要一些对解释器结构的高层次视角。Python解释器是如何工作的？ Python解释器是一个虚拟机,模拟真实计算机的软件。我们这个虚拟机是栈机器，它用几个栈来完成操作（与之相对的是寄存器机器，它从特定的内存地址读写数据）。 Python解释器是一个_字节码解释器_：它的输入是一些命令集合称作_字节码_。当你写Python代码时，词法分析器，语法解析器和编译器生成code object让解释器去操作。每个code object都包含一个要被执行的指令集合 &mdash; 它就是字节码 &mdash; 另外还有一些解释器需要的信息。字节码是Python代码的一个_中间层表示_：它以一种解释器可以理解的方式来表示源代码。这和汇编语言作为C语言和机器语言的中间表示很类似。 A Tiny Interpreter 为了让说明更具体，让我们从一个非常小的解释器开始。它只能计算两个数的和，只能理解三个指令。它执行的所有代码只是这三个指令的不同组合。下面就是这三个指令： LOAD_VALUE ADD_TWO_VALUES PRINT_ANSWER 我们不关心词法，语法和编译，所以我们也不在乎这些指令是如何产生的。你可以想象，你写下7 + 5，然后一个编译器为你生成那三个指令的组合。如果你有一个合适的编译器，你甚至可以用Lisp的语法来写，只要它能生成相同的指令。 假设 7 + 5 生成这样的指令集： what_to_execute = { &quot;instructions&quot;: [(&quot;LOAD_VALUE&quot;, 0), # the first number (&quot;LOAD_VALUE&quot;, 1), # the second number (&quot;ADD_TWO_VALUES&quot;, None), (&quot;PRINT_ANSWER&quot;, None)], &quot;numbers&quot;: [7, 5] } Python解释器是一个_栈机器_，所以它必须通过操作栈来完成这个加法。(\aosafigref{500l.interpreter.stackmachine}.)解释器先执行第一条指令，LOAD_VALUE，把第一个数压到栈中。接着它把第二个数也压到栈中。然后，第三条指令，ADD_TWO_VALUES,先把两个数从栈中弹出，加起来，再把结果压入栈中。最后一步，把结果弹出并输出。 \aosafigure[240pt]{interpreter-images/interpreter-stack.png}{A stack machine}{500l.interpreter.stackmachine} LOAD_VALUE这条指令告诉解释器把一个数压入栈中，但指令本身并没有指明这个数是多少。指令需要一个额外的信息告诉解释器去哪里找到这个数。所以我们的指令集有两个部分：指令本身和一个常量列表。（在Python中，字节码就是我们称为的“指令”，而解释器执行的是_code object_。） 为什么不把数字直接嵌入指令之中？想象一下，如果我们加的不是数字，而是字符串。我们可不想把字符串这样的东西加到指令中，因为它可以有任意的长度。另外，我们这种设计也意味着我们只需要对象的一份拷贝，比如这个加法 7 + 7, 现在常量表 &quot;numbers&quot;只需包含一个7。 你可能会想为什么会需要除了ADD_TWO_VALUES之外的指令。的确，对于我们两个数加法，这个例子是有点人为制作的意思。然而，这个指令却是建造更复杂程序的轮子。比如，就我们目前定义的三个指令，只要给出正确的指令组合，我们可以做三个数的加法，或者任意个数的加法。同时，栈提供了一个清晰的方法去跟踪解释器的状态，这为我们增长的复杂性提供了支持。 现在让我们来完成我们的解释器。解释器对象需要一个栈，它可以用一个列表来表示。它还需要一个方法来描述怎样执行每条指令。比如，LOAD_VALUE会把一个值压入栈中。 class Interpreter: def __init__(self): self.stack = [] def LOAD_VALUE(self, number): self.stack.append(number) def PRINT_ANSWER(self): answer = self.stack.pop() print(answer) def ADD_TWO_VALUES(self): first_num = self.stack.pop() second_num = self.stack.pop() total = first_num + second_num self.stack.append(total) 这三个方法完成了解释器所理解的三条指令。但解释器还需要一样东西：一个能把所有东西结合在一起并执行的方法。这个方法就叫做run_code, 它把我们前面定义的字典结构what-to-execute作为参数，循环执行里面的每条指令，如何指令有参数，处理参数，然后调用解释器对象中相应的方法。 def run_code(self, what_to_execute): instructions = what_to_execute[&quot;instructions&quot;] numbers = what_to_execute[&quot;numbers&quot;] for each_step in instructions: instruction, argument = each_step if instruction == &quot;LOAD_VALUE&quot;: number = numbers[argument] self.LOAD_VALUE(number) elif instruction == &quot;ADD_TWO_VALUES&quot;: self.ADD_TWO_VALUES() elif instruction == &quot;PRINT_ANSWER&quot;: self.PRINT_ANSWER() 为了测试，我们创建一个解释器对象，然后用前面定义的 7 + 5 的指令集来调用run_code。 interpreter = Interpreter() interpreter.run_code(what_to_execute) 显然，它会输出12 尽管我们的解释器功能受限，但这个加法过程几乎和真正的Python解释器是一样的。这里，我们还有几点要注意。 首先，一些指令需要参数。在真正的Python bytecode中，大概有一半的指令有参数。像我们的例子一样，参数和指令打包在一起。注意_指令_的参数和传递给对应方法的参数是不同的。 第二，指令ADD_TWO_VALUES不需要任何参数，它从解释器栈中弹出所需的值。这正是以栈为基础的解释器的特点。 记得我们说过只要给出合适的指令集，不需要对解释器做任何改变，我们就能做多个数的加法。考虑下面的指令集，你觉得会发生什么？如果你有一个合适的编译器，什么代码才能编译出下面的指令集？ what_to_execute = { &quot;instructions&quot;: [(&quot;LOAD_VALUE&quot;, 0), (&quot;LOAD_VALUE&quot;, 1), (&quot;ADD_TWO_VALUES&quot;, None), (&quot;LOAD_VALUE&quot;, 2), (&quot;ADD_TWO_VALUES&quot;, None), (&quot;PRINT_ANSWER&quot;, None)], &quot;numbers&quot;: [7, 5, 8] } 从这点出发，我们开始看到这种结构的可扩展性：我们可以通过向解释器对象增加方法来描述更多的操作（只要有一个编译器能为我们生成组织良好的指令集）。 Variables 接下来给我们的解释器增加变量的支持。我们需要一个保存变量值的指令，STORE_NAME;一个取变量值的指令LOAD_NAME;和一个变量到值的映射关系。目前，我们会忽略命名空间和作用域，所以我们可以把变量和值的映射直接存储在解释器对象中。最后，我们要保证what_to_execute除了一个常量列表，还要有个变量名字的列表。 &gt;&gt;&gt; def s(): ...</div>
    </footer>
  </a>
</article>

        </div>
        
        <div class="col-sm-4">
          <article class="grid">
  <a href="http://qingyunha.github.io/hugo/translation/a-template-engine/">
    <div class="image" style="background-image: url(http://qingyunha.github.io/hugo/images/default.jpg);"></div>
    <footer>
      <div class="date">
        <time>Fri, Oct 9, 2015</time>
      </div>
      <h2 class="title">A Template Engine</h2>
      <div class="summary">Introduction 大多数程序包含大量的逻辑和点点文本数据，编程语言被设计成适合做这样的 事情。但是有些编程任务只需要点点逻辑和大量的文本数据，对于这样的任务， 我们希望有一个更合适工具来做。模板引擎就是这样一个工具。在这一章，我 们会开发一个简单的模板引擎。 一个最常见的需要处理多文本数据的例子是web应用。web应用的一个重要部分 是为浏览器生成HTML网页。很少网页是完全静态的，它们至少包含一些动态数 据，比如用户名。一般情况下，网页有很大一部分动态数据：产品列表，好友消息更 新等等。 同时，每个HTML网页包含大量的静态文本。并且这些网页很大，有成千上万个 字节。这时，web开发者就有一个问题要解决：怎样才能最有效的生成同时包 含静态和动态数据的长字符串？随之而来的问题，这些静态文本其实是前端工 程师写的HTML，他们想希望用自己熟悉的方法处理这些HTML。 为了说明，让我们假设想生成这样一个简单的HTML &lt;p&gt;Welcome, Charlie!&lt;/p&gt; &lt;p&gt;Products:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;Apple: $1.00&lt;/li&gt; &lt;li&gt;Fig: $1.50&lt;/li&gt; &lt;li&gt;Pomegranate: $3.25&lt;/li&gt; &lt;/ul&gt; 这里，用户名会是动态的，产品的名称和数量也是动态的，甚至产品的数量也 不是固定的：在其他情况，可能有更多或更少的产品。 一个简单的方法生成这样的网页是把这样的字符串作为常量写入我们的代码中， 然后把它们拼在一起完成这个网页。动态数据使用类似字符替换的方法插入进 去。有些动态数据是重复的，比如产品列表，这就是说我们会有一些重复的 HTML段，所以我们要单独的去处理它们再和其他的HTML合并起来。 使用这种方法生成我们的HTML的代码会像这样 # The main HTML for the whole page. PAGE_HTML = &quot;&quot;&quot; &lt;p&gt;Welcome, {name}!&lt;/p&gt; &lt;p&gt;Products:&lt;/p&gt; &lt;ul&gt; {products} &lt;/ul&gt; &quot;&quot;&quot; # The HTML for each product displayed. PRODUCT_HTML = &quot;&lt;li&gt;{prodname}: {price}&lt;/li&gt;\n&quot; def make_page(username, products): product_html = &quot;&quot; for prodname, price in products: product_html += PRODUCT_HTML.format(prodname=prodname, price=format_price(price)) html = PAGE_HTML.format(name=username, products=product_html) return html 这样可以，但是我们搞得乱七八糟，HTML成了我们代码里的字符串常量，我们 很难看出这个HTML的结构，因为它被分成一段一段的了。数据格式的细节迷失 在python代码中。并且，为了修改HTML，我们的前端工程师需要修改python代 码。想象一下，如果这个网页比现在这个复杂10倍（或者100倍）我们代码会 是什么样子。 Templates 更好的方法是用模板来生成HTML，或者说把HTML写成一个模板，这样绝大部分 就是静态HTML，再加上一点使用特别符号的动态内容。现在我们的toy网页就成了 下面这样的模板 &lt;p&gt;Welcome, {{user_name}}!&lt;/p&gt; &lt;p&gt;Products:&lt;/p&gt; &lt;ul&gt; {% for product in product_list %} &lt;li&gt;{{ product.name }}: {{ product.price|format_price }}&lt;/li&gt; {% endfor %} &lt;/ul&gt; 这里我们关注的是HTML文本，另外加上一点逻辑。对比现在以文本为中心的方 法和之前以逻辑为中心的方法，我们之前的程序大部分是python代码，这里我 的程序大部分是静态的HTML标签。 在模板中采用的以静态为主的风格和大多数编程语言的工作方式相反。比如 python，几乎所有的源文件都是可执行代码，如果你需要静态文本，你就要把 它嵌到字符串中。 def hello(): print(&quot;Hello world!&quot;) hello() 当python读取这个源文件时，它把def hello():这样的文本解释成要被执行 的指令，而在双引号中的字符 print(&quot;Hello, world!&quot;)被指示成文本。这 就是编程语言如何工作的：动态的，嵌入点点静态内容。静态的内容通过双引号来指示。 一个模板语言把这个过程反过来了，大部分是静态文本，用特殊的符号指示动态 内容。 &lt;p&gt;Welcome, {{user_name}}!&lt;/p&gt; 这里的文本会直接出现在最终的HTML中，直到遇到 {{ 符号，它指示转换到 动态模式，这里user_name变量就会被替换。 字符串格式化函数，比如python的 &quot;foo = {foo}!&quot;.format(foo=17)就是一 个在字符串并插入数据创建文本的微型语言的例子。模板更进一步，加上逻辑结构，比如条件，循环。这只是在程度上不同。 把这些文件叫做模板是因为它们被用来生成大量结构相似的网页，只是细节不同。 为了在程序中使用HTML模板，我们需要一个模板引擎(template engine)：一个需要两个参数的函数，一个是描述页面结构和内容的静态模板，另一个是包含要插入到模板中的动态数据的上下文。模板引擎把模板和上下文结合起来生成完整的HTML字符串，它的任务是解释模板，用真正的数据替换动态的部分。 顺便说一下，HTML对模板引擎并没有什么特别的地方，它可以用来生成任何文本数据。比如，它可以被用来生成纯文本的email信息。但是它通常用于HTML，或许碰巧还有些专门对HTML的特性，比如转义，这个特性让你不用担心插入了对HTML有特殊含义的字符。 Supported Syntax 不同的模板引擎在语法支持上各有不同。我们的模板语法基于Django，一个非常流行的网站框架。因为我们的引擎使用python实现的，一些python的概念会出现在我们的语法中。在上一节的HTML中我们已经看到了一些语法，这里是我们语法的小总结。 上下文中的数据插入到两个大括号中 &lt;p&gt;Welcome, {{user_name}}!&lt;/p&gt; 在模板中可用的数据在上下文中，后面我们详细的讲到。 我们的模板引擎提供了一个简单自由的语法访问数据中的元素。在python中，这些表达式有不同的效果： dict[&quot;key&quot;] obj.attr obj.method() 在我们的语法中，所有这些操作都用点号表示。 dict.key obj.attr obj.method 这个点号会访问对象的属性，字典里的值，如果结果是可调用的，那么就自动调用它。这与python代码不同，你需要不同的语法完成不同的操作。在我们简单的语法下会是这样： &lt;p&gt;The price is: {{product.price}}, with a {{product.discount}}% discount.&lt;/p&gt; 点号可以在一个值上多次使用以访问元素链。 你还可以使用帮助函数，把它们叫做过滤器，用管道符号调用 &lt;p&gt;Short name: {{story.subject|slugify|lower}}&lt;/p&gt; 制作有趣的网页通常需要一点逻辑，所以我们有条件表达式： {% if user.is_logged_in %} &lt;p&gt;Welcome, {{ user.name }}!&lt;/p&gt; {% else %} &lt;p&gt;&lt;a href=&quot;/login&quot;&gt;Log in &lt;/a&gt;&lt;/p&gt; {% endif %} 循环可以让我们在网页里包含数据集合： &lt;p&gt;Products:&lt;/p&gt; &lt;ul&gt; {% for product in product_list %} &lt;li&gt;{{ product.name }}: {{ product.price|format_price }}&lt;/li&gt; {% endfor %} &lt;/ul&gt; 和其他的编程语言一样，条件和循环可以嵌套使用。 最后，我们可以对模板注释 {# This is the best template ever!</div>
    </footer>
  </a>
</article>

        </div>
        
      </div>

      


    </div>

    <div class="col-md-3">
      <aside class="site">

  

  

  <section>
    <header>LatestPosts</header>
    <div>
      
      <article class="li">
  <a href="http://qingyunha.github.io/hugo/blog/python-name/" class="clearfix">
    <div class="image" style="background-image: url(http://qingyunha.github.io/hugo/images/default.jpg);"></div>
    <footer>
      <div class="date">
        <time>Mon, Aug 22, 2016</time>
      </div>
      <h2 class="title">python值传递 or 引用传递</h2>
    </footer>
  </a>
</article>

      
      <article class="li">
  <a href="http://qingyunha.github.io/hugo/blog/read-memcached-1.2.0/" class="clearfix">
    <div class="image" style="background-image: url(http://qingyunha.github.io/hugo/images/default.jpg);"></div>
    <footer>
      <div class="date">
        <time>Thu, Aug 18, 2016</time>
      </div>
      <h2 class="title">memcached-1.2.0 源码解读</h2>
    </footer>
  </a>
</article>

      
      <article class="li">
  <a href="http://qingyunha.github.io/hugo/wiki/git-proxy/" class="clearfix">
    <div class="image" style="background-image: url(http://qingyunha.github.io/hugo/images/default.jpg);"></div>
    <footer>
      <div class="date">
        <time>Sat, Aug 6, 2016</time>
      </div>
      <h2 class="title">git proxy</h2>
    </footer>
  </a>
</article>

      
      <article class="li">
  <a href="http://qingyunha.github.io/hugo/blog/python-logging/" class="clearfix">
    <div class="image" style="background-image: url(http://qingyunha.github.io/hugo/images/default.jpg);"></div>
    <footer>
      <div class="date">
        <time>Sat, Jul 9, 2016</time>
      </div>
      <h2 class="title">python logging</h2>
    </footer>
  </a>
</article>

      
      <article class="li">
  <a href="http://qingyunha.github.io/hugo/translation/crawler/" class="clearfix">
    <div class="image" style="background-image: url(http://qingyunha.github.io/hugo/images/default.jpg);"></div>
    <footer>
      <div class="date">
        <time>Sat, Jul 9, 2016</time>
      </div>
      <h2 class="title">A Web Crawler With asyncio Coroutines</h2>
    </footer>
  </a>
</article>

      
      <article class="li">
  <a href="http://qingyunha.github.io/hugo/wiki/flask-dev/" class="clearfix">
    <div class="image" style="background-image: url(http://qingyunha.github.io/hugo/images/default.jpg);"></div>
    <footer>
      <div class="date">
        <time>Sat, May 21, 2016</time>
      </div>
      <h2 class="title">成为Flask贡献者</h2>
    </footer>
  </a>
</article>

      
      <article class="li">
  <a href="http://qingyunha.github.io/hugo/translation/python-interpreter/" class="clearfix">
    <div class="image" style="background-image: url(http://qingyunha.github.io/hugo/images/default.jpg);"></div>
    <footer>
      <div class="date">
        <time>Mon, May 9, 2016</time>
      </div>
      <h2 class="title">A Python Interpreter Written in Python</h2>
    </footer>
  </a>
</article>

      
      <article class="li">
  <a href="http://qingyunha.github.io/hugo/translation/a-template-engine/" class="clearfix">
    <div class="image" style="background-image: url(http://qingyunha.github.io/hugo/images/default.jpg);"></div>
    <footer>
      <div class="date">
        <time>Fri, Oct 9, 2015</time>
      </div>
      <h2 class="title">A Template Engine</h2>
    </footer>
  </a>
</article>

      
    </div>
  </section>

  
  <section>
    <header>category</header>
    <div>
      <ul>
        <li><a href="http://qingyunha.github.io/hugo/categories/blog">blog</a></li><li><a href="http://qingyunha.github.io/hugo/categories/translation">translation</a></li><li><a href="http://qingyunha.github.io/hugo/categories/wiki">wiki</a></li>
      </ul>
    </div>
  </section>
  
  <section>
    <header>tag</header>
    <div>
      <ul>
        <li><a href="http://qingyunha.github.io/hugo/tags/python">python</a></li><li><a href="http://qingyunha.github.io/hugo/tags/asyn">asyn</a></li><li><a href="http://qingyunha.github.io/hugo/tags/git">git</a></li><li><a href="http://qingyunha.github.io/hugo/tags/interpreter">interpreter</a></li><li><a href="http://qingyunha.github.io/hugo/tags/logging">logging</a></li><li><a href="http://qingyunha.github.io/hugo/tags/memcached">memcached</a></li><li><a href="http://qingyunha.github.io/hugo/tags/proxy">proxy</a></li><li><a href="http://qingyunha.github.io/hugo/tags/template-engine">template-engine</a></li><li><a href="http://qingyunha.github.io/hugo/tags/virtual-machine">virtual-machine</a></li>
      </ul>
    </div>
  </section>
  

</aside>

    </div>

  </div>

</div>


<footer class="l-footer">
  <p>&copy; 2016 Qing Yun</p>
  <p>Powered by <a href="http://gohugo.io" target="_blank" rel="nofollow">Hugo</a>, Theme <a href="https://github.com/dim0627/hugo_theme_robust" target="_blank" rel="nofollow">robust</a> designed by <a href="http://yet.unresolved.xyz" target="_blank" rel="nofollow">Daisuke Tsuji</a></p>
</footer>

<script src="//code.jquery.com/jquery-2.1.3.min.js"></script>
<script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>



  </body>
</html>


